<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>恍惚</title>
  
  <subtitle>人必须坚持不懈地生成和创造才能臻于完满</subtitle>
  <link href="https://www.liuzx.me/atom.xml" rel="self"/>
  
  <link href="https://www.liuzx.me/"/>
  <updated>2022-08-31T02:40:40.340Z</updated>
  <id>https://www.liuzx.me/</id>
  
  <author>
    <name>恍惚</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://www.liuzx.me/2022/08/31/Docker%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.liuzx.me/2022/08/31/Docker%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-08-31T02:16:23.414Z</published>
    <updated>2022-08-31T02:40:40.340Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Docker-介绍&quot;&gt;&lt;a href=&quot;#Docker-介绍&quot; class=&quot;headerlink&quot; title=&quot;Docker 介绍&quot;&gt;&lt;/a&gt;Docker 介绍&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;虚拟化技术与容器技术&lt;ol&gt;
&lt;li&gt;虚拟化技术的理解&lt;ol&gt;
&lt;li&gt;它是一种将计算机物理资源抽象化，转化成计算机虚拟资源以提供给程序使用&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;虚拟化技术很好地解决了跨平台兼容的问题&lt;/li&gt;
&lt;li&gt;虚拟化只是提高了计算机计算机资源的利用率，并不会减少资源的占用。&lt;/li&gt;
&lt;li&gt;资源隔离&lt;ol&gt;
&lt;li&gt;将程序分隔在不同的运行环境中&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;容器技术&lt;ol&gt;
&lt;li&gt;操作系统提供接口，让多个应用程序在不同的环境中独立运行，互不干扰。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Docker 介绍&lt;ol&gt;
&lt;li&gt;Docker 属于操作系统层面的虚拟化技术&lt;/li&gt;
&lt;li&gt;Docker 与传统的虚拟化技术的不同之处&lt;ol&gt;
&lt;li&gt;Docker 没有虚拟出硬件，并且它的容器直接运行于宿主内核，容器内并没有自己的内核&lt;/li&gt;
&lt;li&gt;传统的虚拟化技术需要虚拟出硬件，在其上运行一个操作系统，并且在这个操作系统里面运行应用程序&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;命名空间&lt;ol&gt;
&lt;li&gt;集合相同模块的类，区分不同模块的同名类&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.liuzx.me/2022/08/27/Swiper%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://www.liuzx.me/2022/08/27/Swiper%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2022-08-26T23:59:50.614Z</published>
    <updated>2022-08-26T23:59:50.897Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;Swiper使用方法&quot;&gt;&lt;a href=&quot;#Swiper使用方法&quot; class=&quot;headerlink&quot; title=&quot;Swiper使用方法&quot;&gt;&lt;/a&gt;Swiper使用方法&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;npm i</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.liuzx.me/2022/08/26/%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"/>
    <id>https://www.liuzx.me/2022/08/26/%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/</id>
    <published>2022-08-26T11:55:34.489Z</published>
    <updated>2022-08-26T11:55:34.712Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;异步操作&quot;&gt;&lt;a href=&quot;#异步操作&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.liuzx.me/2022/08/26/this%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://www.liuzx.me/2022/08/26/this%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-08-26T11:55:15.407Z</published>
    <updated>2022-08-26T13:37:45.911Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;this-关键字&quot;&gt;&lt;a href=&quot;#this-关键字&quot; class=&quot;headerlink&quot; title=&quot;this 关键字&quot;&gt;&lt;/a&gt;this 关键字&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;this 总是返回一个对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;this 的值为属性或方法当前所在的对象(环境)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用场合 1. 在全局环境下，this 的值为顶层环境 window。 2. 在构造函数中，this 指向实例对象。 3. 在对象的方法中，this 指向当前方法所在的对象，但如果对一个对象进行赋值时，this 的指向就会改变了。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.liuzx.me/2022/08/26/Promise%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.liuzx.me/2022/08/26/Promise%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-08-26T11:54:56.482Z</published>
    <updated>2022-08-26T13:35:54.987Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Promise-对象&quot;&gt;&lt;a href=&quot;#Promise-对象&quot; class=&quot;headerlink&quot; title=&quot;Promise 对象&quot;&gt;&lt;/a&gt;Promise 对象&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Promise 是一种异步编程的解决方案，简单来说就像一种容器，里面保存着某个只有未来才会结束的事件的结果。&lt;/li&gt;
&lt;li&gt;Promise 的三种状态，pending(进行中),fulfilled(已完成),rejected(已失败)。&lt;/li&gt;
&lt;li&gt;Promise 的最终状态由异步操作之后的结果决定，并且状态改变之后不会再变。&lt;/li&gt;
&lt;li&gt;Promise 内部的错误不会影响到 Promise 外部的代码</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.liuzx.me/2022/08/26/package.json%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.liuzx.me/2022/08/26/package.json%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-08-26T11:54:37.309Z</published>
    <updated>2022-08-26T13:36:11.900Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;package-json-介绍&quot;&gt;&lt;a href=&quot;#package-json-介绍&quot; class=&quot;headerlink&quot; title=&quot;package.json 介绍&quot;&gt;&lt;/a&gt;package.json 介绍&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;package.json 作用&lt;ol&gt;
&lt;li&gt;包管理配置文件，管理项目中所依赖的包的配置&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;package-lock 作用&lt;ol&gt;
&lt;li&gt;本质是锁定(lock)包的版本</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.liuzx.me/2022/08/26/Module%E8%AF%AD%E6%B3%95/"/>
    <id>https://www.liuzx.me/2022/08/26/Module%E8%AF%AD%E6%B3%95/</id>
    <published>2022-08-26T11:54:18.568Z</published>
    <updated>2022-08-26T13:36:26.184Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Module-语法&quot;&gt;&lt;a href=&quot;#Module-语法&quot; class=&quot;headerlink&quot; title=&quot;Module 语法&quot;&gt;&lt;/a&gt;Module 语法&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;ES6 模块可在编译时(即静态阶段)确定模块的编译关系，而 CommonJS 只能在运行时确定模块的依赖关系，所以 ES6 模块可实现静态优化。&lt;/li&gt;
&lt;li&gt;ES6 模块支持按需加载需要的模块方法，但 CommonJS 只能加载所有的模块方法。&lt;/li&gt;
&lt;li&gt;ES6 模块自动采用严格模式。&lt;/li&gt;
&lt;li&gt;export 命令规定模块的对外接口，import 命令用于从模块中导入需要的功能。&lt;/li&gt;
&lt;li&gt;export 命令可以输出变量，函数和类。&lt;/li&gt;
&lt;li&gt;通过 import 命令导入的模块，可在模块导入语句的头部提前执行。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.liuzx.me/2022/08/26/Module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/"/>
    <id>https://www.liuzx.me/2022/08/26/Module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-08-26T11:53:49.957Z</published>
    <updated>2022-08-26T13:36:41.987Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Module-的加载实现&quot;&gt;&lt;a href=&quot;#Module-的加载实现&quot; class=&quot;headerlink&quot; title=&quot;Module 的加载实现&quot;&gt;&lt;/a&gt;Module 的加载实现&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;在浏览器中加载 ES6 模块&lt;ol&gt;
&lt;li&gt;&amp;lt;javascript&amp;gt;标签的两种属性 async 与 defer 的相同点是都是异步加载。&lt;/li&gt;
&lt;li&gt;&amp;lt;javascript&amp;gt;标签的两种属性 async 与 defer 区别&lt;ol&gt;
&lt;li&gt;defer：页面渲染完后执行。&lt;/li&gt;
&lt;li&gt;async：脚本下载完成后执行，同时中断当前的渲染。&lt;/li&gt;
&lt;li&gt;多个 defer 脚本按顺序执行，多个 async 脚本执行顺序不能保证。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;模块顶层的 this 指向 undefined。&lt;/li&gt;
&lt;li&gt;在浏览器中加载 ES6 模块时，需要在&amp;lt;javascript&amp;gt;标签中指定 type&amp;#x3D;”module”属性。&lt;/li&gt;
&lt;li&gt;浏览器中的 ES6 模块，默认是 defer 属性的异步加载。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.liuzx.me/2022/08/26/Generator%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95/"/>
    <id>https://www.liuzx.me/2022/08/26/Generator%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95/</id>
    <published>2022-08-26T11:53:29.539Z</published>
    <updated>2022-08-26T23:40:14.102Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Generator-函数语法&quot;&gt;&lt;a href=&quot;#Generator-函数语法&quot; class=&quot;headerlink&quot; title=&quot;Generator 函数语法&quot;&gt;&lt;/a&gt;Generator 函数语法&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Generator 相当于一个状态机，里面封装了多种内部状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建 Generator 函数时，Function 关键字跟函数名之间要有*星号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用 Generator 函数后，不会执行里面的代码，而是生成一个迭代器对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;返回的迭代器对象可以反复使用 next()方法迭代内部状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 next 方法会返回一个对象，这个对象有两个属性 1. value：当前状态的值，即 yield 表达式的值 2. done：迭代是否结束&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.liuzx.me/2022/08/26/ECMAScript6/"/>
    <id>https://www.liuzx.me/2022/08/26/ECMAScript6/</id>
    <published>2022-08-26T11:53:07.043Z</published>
    <updated>2022-08-26T13:38:37.971Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;ECMAScript6&quot;&gt;&lt;a href=&quot;#ECMAScript6&quot; class=&quot;headerlink&quot; title=&quot;ECMAScript6&quot;&gt;&lt;/a&gt;ECMAScript6&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;JavaScript 为动态类型语言。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;静态语言：在编译阶段便检查数据类型。动态语言：在执行期间才检查语言的数据类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;扩展运算符 1. 取出参数对象的所有可遍历属性，拷贝到当前对象中。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.liuzx.me/2022/08/26/async%E5%87%BD%E6%95%B0/"/>
    <id>https://www.liuzx.me/2022/08/26/async%E5%87%BD%E6%95%B0/</id>
    <published>2022-08-26T11:52:43.605Z</published>
    <updated>2022-08-26T11:52:43.893Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;async函数&quot;&gt;&lt;a href=&quot;#async函数&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.liuzx.me/2022/08/26/Iterator%E9%81%8D%E5%8E%86%E5%99%A8/"/>
    <id>https://www.liuzx.me/2022/08/26/Iterator%E9%81%8D%E5%8E%86%E5%99%A8/</id>
    <published>2022-08-26T11:52:15.049Z</published>
    <updated>2022-08-26T11:52:15.690Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;async函数&quot;&gt;&lt;a href=&quot;#async函数&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.liuzx.me/2022/08/26/CORS%E9%80%9A%E4%BF%A1/"/>
    <id>https://www.liuzx.me/2022/08/26/CORS%E9%80%9A%E4%BF%A1/</id>
    <published>2022-08-26T11:51:48.577Z</published>
    <updated>2022-08-26T13:33:59.772Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;CORS-通信&quot;&gt;&lt;a href=&quot;#CORS-通信&quot; class=&quot;headerlink&quot; title=&quot;CORS 通信&quot;&gt;&lt;/a&gt;CORS 通信&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;CORS（Cross-Origin-Resource-Sharing），中文名跨域资源共享。&lt;/li&gt;
&lt;li&gt;CORS 的作用是允许浏览器向跨域服务器发送 XMLHttpRequest（XHR）。&lt;/li&gt;
&lt;li&gt;实现 CORS 跨域通信，主要看服务器是否实现 CORS 接口，也就是说主要在服务器端配置&lt;/li&gt;
&lt;li&gt;服务器端配置 CORS 跨域的方法是设置 Access-Control-Allow-Origin</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.liuzx.me/2022/08/26/VueRouter/"/>
    <id>https://www.liuzx.me/2022/08/26/VueRouter/</id>
    <published>2022-08-26T11:47:29.153Z</published>
    <updated>2022-08-26T13:39:02.058Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;VueRouter&quot;&gt;&lt;a href=&quot;#VueRouter&quot; class=&quot;headerlink&quot; title=&quot;VueRouter&quot;&gt;&lt;/a&gt;VueRouter&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;导入 vue 及 vue-router 库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装 vue-router 插件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;导入路由组件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建路由数组即 routes 数组，数组一般有 1. path 属性定义访问路径 2. component 属性指定组件名 3. redirect 属性用于路由重定向 4. meta 属性是一个对象，为路由记录添加其他额外信息，通过这个信息以实现控制路由的访问等功能&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.liuzx.me/2022/08/26/Vuex/"/>
    <id>https://www.liuzx.me/2022/08/26/Vuex/</id>
    <published>2022-08-26T11:45:49.861Z</published>
    <updated>2022-08-26T23:44:00.588Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Vuex&quot;&gt;&lt;a href=&quot;#Vuex&quot; class=&quot;headerlink&quot; title=&quot;Vuex&quot;&gt;&lt;/a&gt;Vuex&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;作用：集中管理项目中组件公用的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用场景：项目过大，组件多，并且数据量多的情况下可以使用 vuex&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;vuex 的状态是响应式的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;mutations 不能直接更改状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vuex 使用步骤： 1. 创建 store 目录，在这个目录下创建 index.js 文件 2. 导入 Vue 及 Vuex 库 3. 安装 Vuex 库，即 Vue.use(Vuex) 4. 创建 vuex 实例，通过 new Vuex.Store({})方法 5. 向外导出 Vuex 实例 6. 在入口文件中导入 vuex 实例 7. 注册 vuex 实例&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>DeepL</title>
    <link href="https://www.liuzx.me/2021/06/19/DeepL/"/>
    <id>https://www.liuzx.me/2021/06/19/DeepL/</id>
    <published>2021-06-19T01:33:43.000Z</published>
    <updated>2021-08-07T05:58:51.000Z</updated>
    
    
    <summary type="html">DeepL才是最强大的翻译器！</summary>
    
    
    
    <category term="分享" scheme="https://www.liuzx.me/categories/%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="工具" scheme="https://www.liuzx.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>语义化版本2.0.0介绍</title>
    <link href="https://www.liuzx.me/2021/06/15/semver2.0.0/"/>
    <id>https://www.liuzx.me/2021/06/15/semver2.0.0/</id>
    <published>2021-06-15T04:43:23.000Z</published>
    <updated>2022-08-26T23:43:51.508Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;语义化版本-2-0-0-介绍&quot;&gt;&lt;a href=&quot;#语义化版本-2-0-0-介绍&quot; class=&quot;headerlink&quot; title=&quot;语义化版本 2.0.0 介绍&quot;&gt;&lt;/a&gt;语义化版本 2.0.0 介绍&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;语义化版本是为了解决软件开发过程中依赖关系混乱或者依赖锁死的情况。&lt;/p&gt;
&lt;p&gt;它的标准格式如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;x.y.z&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中 x 表示主版本号，y 表示次版本号，z 表示修订号。&lt;/p&gt;</summary>
    
    
    
    <category term="扩展阅读" scheme="https://www.liuzx.me/categories/%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="版本号" scheme="https://www.liuzx.me/tags/%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>npm常用命令</title>
    <link href="https://www.liuzx.me/2020/08/04/npm-command/"/>
    <id>https://www.liuzx.me/2020/08/04/npm-command/</id>
    <published>2020-08-04T04:43:23.000Z</published>
    <updated>2022-08-26T23:43:28.849Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;npm-常见命令&quot;&gt;&lt;a href=&quot;#npm-常见命令&quot; class=&quot;headerlink&quot; title=&quot;npm 常见命令&quot;&gt;&lt;/a&gt;npm 常见命令&lt;/h1&gt;&lt;h2 id=&quot;一-npm-amp-yarn-介绍&quot;&gt;&lt;a href=&quot;#一-npm-amp-yarn-介绍&quot; class=&quot;headerlink&quot; title=&quot;一.npm&amp;amp;yarn 介绍&quot;&gt;&lt;/a&gt;一.npm&amp;amp;yarn 介绍&lt;/h2&gt;&lt;p&gt;npm 是一个基于 Node.js 的包管理工具。&lt;br&gt;yarn 是 Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 包管理工具,与 npm 相比有些优势。&lt;br&gt;npm 在安装 Node.js 时会被一并安装，yarn 则需要额外安装。&lt;/p&gt;
&lt;h2 id=&quot;二-npm-amp-cnpm-的关系&quot;&gt;&lt;a href=&quot;#二-npm-amp-cnpm-的关系&quot; class=&quot;headerlink&quot; title=&quot;二.npm&amp;amp;cnpm 的关系&quot;&gt;&lt;/a&gt;二.npm&amp;amp;cnpm 的关系&lt;/h2&gt;&lt;h3 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.介绍&quot;&gt;&lt;/a&gt;1.介绍&lt;/h3&gt;&lt;p&gt;由于 npm 服务器在国外，所以在国内安装速度不是很理想，于是淘宝团队开发了一个 npmjs.org 的镜像，可以有效解决下载过于缓慢的问题。这是淘宝团队对它的介绍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10 分钟 一次以保证尽量与官方服务同步。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2-安装&quot;&gt;&lt;a href=&quot;#2-安装&quot; class=&quot;headerlink&quot; title=&quot;2.安装&quot;&gt;&lt;/a&gt;2.安装&lt;/h3&gt;&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;npm install -g cnpm --registry&amp;#x3D;https:&amp;#x2F;&amp;#x2F;registry.npm.taobao.org&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="https://www.liuzx.me/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="npm" scheme="https://www.liuzx.me/tags/npm/"/>
    
    <category term="yarn" scheme="https://www.liuzx.me/tags/yarn/"/>
    
    <category term="cnpm" scheme="https://www.liuzx.me/tags/cnpm/"/>
    
  </entry>
  
  <entry>
    <title>Java反射</title>
    <link href="https://www.liuzx.me/2020/06/15/java-reflection/"/>
    <id>https://www.liuzx.me/2020/06/15/java-reflection/</id>
    <published>2020-06-15T04:43:23.000Z</published>
    <updated>2021-08-07T05:58:51.000Z</updated>
    
    
    <summary type="html">Java进阶学习之反射</summary>
    
    
    
    <category term="技术笔记" scheme="https://www.liuzx.me/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="https://www.liuzx.me/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/Java/"/>
    
    
    <category term="Java" scheme="https://www.liuzx.me/tags/Java/"/>
    
    <category term="Java反射" scheme="https://www.liuzx.me/tags/Java%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Learning how to learn part1</title>
    <link href="https://www.liuzx.me/2020/06/15/Learning%20how%20to%20learn%20prat%201/"/>
    <id>https://www.liuzx.me/2020/06/15/Learning%20how%20to%20learn%20prat%201/</id>
    <published>2020-06-15T04:32:33.000Z</published>
    <updated>2021-08-07T05:58:51.000Z</updated>
    
    
    <summary type="html">Coursera课程-Learning how to learn 章节1 总结~</summary>
    
    
    
    <category term="Coursera课程" scheme="https://www.liuzx.me/categories/Coursera%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="Coursera" scheme="https://www.liuzx.me/tags/Coursera/"/>
    
  </entry>
  
</feed>
