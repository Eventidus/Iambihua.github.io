<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>哔哗的小站</title>
  
  <subtitle>大音希声，大象无形</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-01-01T09:19:12.097Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>平平淡淡无奇贰零贰零年总结</title>
    <link href="http://example.com/2021/06/05/Thinking/summary-2020/"/>
    <id>http://example.com/2021/06/05/Thinking/summary-2020/</id>
    <published>2021-06-05T03:47:06.082Z</published>
    <updated>2021-01-01T09:19:12.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="理由"><a href="#理由" class="headerlink" title="理由"></a>理由</h2><p>看着网络平台上很多人都在晒自己的2020年度总结，有的是长篇大文，有的甚至连自己出生到现在的30年人生也总结了。</p><p>我突然就很想写一篇自己的年度总结。</p><p>如果写成了，那将会是我人生的第一篇年度总结，往后也可能会坚持继续写下去吧。</p><p>但谁又知道呢，未来实在太抽象。</p><p>可能是随大流吧，年前写篇总结，已经成为很多人跨年的习俗之一。</p><p>也可能是因为太无聊，今年元旦又是宅寝室，写篇年度总结打发打发一下时间吧。</p><p>本来昨晚上就该好好写写的，结果因为一系列原因(懒)才拖延到现在。</p><p>现在终于可以静下心好好写一篇了。</p><p>我是个随性随心的人，所以今天这篇年度总结随便写写吧。</p><p>主要写我对这一年的思考，如果要我对2020年做个全面系统总结，那便是—平淡无奇，但更多的是失望吧。</p><h3 id="关于友情"><a href="#关于友情" class="headerlink" title="关于友情"></a>关于友情</h3><p>该怎么说呢，我对友情这玩意儿越来越陌生了。</p><p>现在几乎已经没有什么可以真正交心谈心的朋友了。</p><p>不知道是我刻意疏离友情还是友情疏离我，抑或是本来就不存在友情吧。</p><p>无所谓了，尽管现在还有一些心里很在乎的人，但我现在越来越不想主动联系了。</p><p>友情不应该是双方两人一直努力维持的么，怎么到头来几乎却是我一个人主动…</p><p>如果只有单方刻意维持一段友情，那将会很心累。</p><p>说到这，我突然想对之前伤害过的女孩子再次说声对不起，她是我之前特别要好的朋友，尽管已经说过无数次，但我心里愧疚一直存在。(是我自己的问题，跟上面关于友情的阐述无关)</p><p>而且从那以后，我们之间就已经产生隔阂了，但我永远不会对她产生隔阂，我不知道要如何才能消除她心里的那个隔阂，我伤得她实在太深了。</p><p>对不起！</p><p>到现在已经过去快一年了，经常在朋友圈看到她发的生活动态，看起来她过得很不错。</p><p>那么，就适当放下这一段友情吧，我希望再次见面的时候，我们之间再也没有隔阂。</p><p>纯纯真真天真无邪如当年。</p><h3 id="关于亲情"><a href="#关于亲情" class="headerlink" title="关于亲情"></a>关于亲情</h3><p>亲情，在我看来，是我人生中最重要无比的感情。</p><p>可以没有亲情也可以没有爱情，但必须拥有亲情。</p><p>亲情是我心灵最后的避港湾，是我最后的依靠。</p><p>今年跟以往一样，我家人依然很爱我，我也很爱我家人，所以无须多说。</p><h3 id="关于爱情"><a href="#关于爱情" class="headerlink" title="关于爱情"></a>关于爱情</h3><p>今年还是单身，直接逃过吧！</p><h3 id="关于学习"><a href="#关于学习" class="headerlink" title="关于学习"></a>关于学习</h3><p>学习相对来说，跟以往相比懒散了，而且懒散程度达到了前所未有的高度，甚至想退学。</p><p>倒不是说我不喜欢学习； ，只是感兴趣的课程实在太少，而且这些课又很水，学了实在是浪费时间，当然，拿奖学金或者什么的，就另说了。</p><p>我真正在乎的，是专业课学习，这才是有用的课程，也是我目前唯一感兴趣的课程。</p><p>我这个人啊，对于不感兴趣的东西，会特别排斥，除非它对我有实用用处，没错，我是一个实用主义者。</p><p>很好，今年依然没有学到很多东西，学的都是一些皮毛，真想抽自己一嘴巴子。</p><p>那么今年一定要多多努力🦆，多看书多思考多总结，少玩📱！</p><p>这里一定要加黑处理，<strong>多看书多思考多总结，少玩📱！</strong></p><h3 id="Ending"><a href="#Ending" class="headerlink" title="Ending"></a>Ending</h3><p>要么庸俗要么孤独。</p><p>2021，请多多关照！</p><p>祝大家元旦快乐！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="思考" scheme="http://example.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="年度总结" scheme="http://example.com/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>如果问题无法解决，那就换个问法继续解决</title>
    <link href="http://example.com/2021/06/05/Thinking/NIC_dirver/"/>
    <id>http://example.com/2021/06/05/Thinking/NIC_dirver/</id>
    <published>2021-06-05T03:47:06.079Z</published>
    <updated>2020-08-24T02:33:39.089Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前几天早上起床洗嗽后，开始开启Window系统解决昨晚遗留的问题。</p><p>可刚显示桌面后却发现电脑是无网络状态，打开网络图标发现所有WIFI信号全消失了，只有有线网络可以使用。</p><p>于是我又打开网络适配器选项界面，发现WLAN选项不见了，其他该有的都在。</p><p>我马上想到可能是网卡驱动的问题，于是又打开设备管理器中的网络适配器。</p><p>果不其然，有些网卡驱动消失，有些是中间出现感叹号，也有些则正常。</p><p><img src="https://cdn.jsdelivr.net/gh/Iambihua/CDN/img/20200822224027.jpg" alt="88190006c3de572f012d7cafdd30a8c2428bcfde80dc26f72"></p><p>于是我想到的第一个解决方法是重新安装网卡驱动。</p><p>我先是从本地列表中安装网卡驱动，但显示安装超时。</p><p>不得已我只能借助相应软件来辅助安装。</p><p>我第一个想到的就是驱动精灵，所以我通过另一台笔记本电脑使用U盘安装了驱动精灵，毕竟也没得网线可连接。</p><p>然后把它拷贝到我的电脑，令人失望的是，驱动精灵竟然要联网才能正常安装网卡驱动。</p><p>我只能从网站下载相应无线网卡驱动安装包到U盘，最后通过U盘安装网卡驱动。</p><p>但遗憾还是失败了。</p><p>联想官方，微软官方的网卡驱动安装包都无法修复问题。</p><p>当然我也试过了百度&amp;谷歌，所有能试的都试了，还是没有办法解决。</p><p>于是我放弃了，也不愿意重装系统，要不然血亏呀，打算等几天回家后使用家里的网线修复问题。</p><p>等到第二天，因为自己实在按耐不住使用电脑的寂寞，毕竟每天都在使用电脑，这已经是个人长期习惯了~</p><p>不能使用电脑的每一天，想她~</p><p>所以打算再战亿百回。</p><p>我先是打开设备管理器中的网卡驱动属性，看到设备状态为非正常状态，返回了错误代码。</p><p>于是我复制这段错误代码，打算在谷歌搜搜看。</p><p>可算在CSDN找到了与我的错误代码一致的搜索结果。</p><p>但没想到解决办法是如此简单粗暴——清理注册表！</p><p>于是我使用CCleaner的清理注册表功能，然后再重启电脑。</p><p>很神奇，竟然修复了，当时真的是非常惊奇又开心~</p><p>这使我开始反思之前的解决办法。</p><p>我得出的几点总结如下：</p><ul><li><strong>如果问题无法解决，那就换个问法，至少对于互联网搜索来说是这样。</strong></li><li><strong>如果Window系统出现问题，也许可以尝试清理注册表的方法。</strong></li><li><strong>别开启Window系统自动更新功能，可能会导致致命级的Bug!，建议手动升级保险点</strong></li></ul><p>对于网卡驱动突然损坏的原因，我当时猜想是因为Window自动更新的Bug,因为我本身也为window系统开启了自动更新功能。</p><p>毕竟晚上睡前还用得好好的，第二天竟突然出现这样的问题，实在有足够的理由怀疑是window更新的原因。</p><p>后来的某一天，在某个群里发现有个群友也因为Window更新后丢失网卡驱动。</p><p>这让我更加坚信我的怀疑，没错就是Window更新的Bug，微软这锅你得给我背定了。</p><p>同时也让我暗自流泪伤心：我什么时候才能拥有一台属于自己的MAC呀！QWQ</p>]]></content>
    
    
    <summary type="html">记一次修复网卡驱动过程中的思考</summary>
    
    
    
    <category term="思考" scheme="http://example.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="网卡驱动" scheme="http://example.com/tags/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8/"/>
    
    <category term="注册表" scheme="http://example.com/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>确定自己努力的方向</title>
    <link href="http://example.com/2021/06/05/Thinking/learning-direction/"/>
    <id>http://example.com/2021/06/05/Thinking/learning-direction/</id>
    <published>2021-06-05T03:47:06.068Z</published>
    <updated>2020-09-25T10:06:05.376Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>前几天跟一位老朋友聊了下专业上的事，以及以后的就业选择。<br>她已经打算报考教资，但是以后并不打算当老师，报考教资也无非在毕业时多点人生选择。<br>她更愿意去互联网企业体验，所以想努力一把，然而苦于没有明确的学习方向。<br>由于时间限制，我们当时并没有聊太多。<br>但是我觉得我可以趁空写一篇博文，一来总结自己的思考经验，二来也希望对她有一定的借鉴帮助吧。<br>当然此文除了为那位朋友写，也是为昨晚痛哭流涕开始努力的室友写！😜<br>注意内容仅为个人建议，而且内容适用于计算机专业学生，实际还是以大家自身真实情况为准。</p></blockquote><span id="more"></span><h2 id="1-确定学习方向"><a href="#1-确定学习方向" class="headerlink" title="1.确定学习方向"></a>1.确定学习方向</h2><p>关于如何确定学习方向，这个大家要以自身兴趣确定好自己以后的就业方向。</p><p>对于计算机类专业的学生来说，互联网企业的职业种类众多，的确很难选择，短时间内也不能尽快确定。</p><p>所以我的建议是，尽量选择与自己专业搭边的，而且最好还是自身要感兴趣。</p><p><del>兴趣是最好的老师</del>，有兴趣才更能坚持下去，面对众多困难挑战，更能从容不迫吧。</p><p>那么如何确定就业方向呢？答案就是多上网搜索了解。</p><p>你必须要了解的，万事开头难，有个好的开始便是走对了一半的路。</p><p>如果这样漫无目的的学习，到头来可能还是什么也没学会吧，就算有，也不会形成相应的专业能力。</p><p>关于就业方向的确定，其实不好完成，因为它需要花费大量的时间精力。</p><p>所以我希望大家先放下手头的学习，多一点耐心，多一点时间来了解相关就业方向。</p><p>确定了就业方向后，就要开始确定与职位相关的学习方向，这个比较简单。</p><p>怎么确定呢，同样也是多查资料多了解，强烈推荐大家使用谷歌搜索。</p><p>还有什么比这更好的中文搜索引擎呢？某度就不用说了，按体验和实用性来说，大家都清楚。</p><p>在我看来，确定学习方向的一个关键重要标志就是确定了相关学习方向的所有知识栈，即整个知识框架。</p><p>有了这个知识框架，你便能更好地安排学习任务，各个击破，有针对性地学习。</p><p>比如我给出下图作为例子。<br><img src="https://cdn.jsdelivr.net/gh/Iambihua/CDN/img/20200925174532.png" alt="Java后端学习路线"></p><p>等你差不多学完所有知识框架，你在某方向所要求的专业能力便已经培养起来了。</p><p>这时候的你会更有竞争能力，至少你已经培养起了足够的能力。</p><h2 id="2-学校课程"><a href="#2-学校课程" class="headerlink" title="2.学校课程"></a>2.学校课程</h2><p>可能你所确定的学习方向，与学校课程没有关联性。</p><p>我也希望你不要放弃，要把重点放在自己的学习方向上，学校课程能学就学，但尽量不要挂科。</p><p>因为你要考虑挂科的后果，比如补考或重修的时间成本，考研，奖学金等等。</p><p>我本身学的是计算机科学与技术，然而这专业我不是很满意，因为这专业还要学硬件。</p><p>而我对硬件完全就是提不起兴趣，有时候甚至学不懂，我对软件才是真爱。</p><p>虽然这专业兼修硬软，但是我不确定它的主要方向是否是软件。</p><p>但已经无所谓，我作为一名计算机科学与技术学生，自学软件工程专业。</p><p>感觉也没有很大的压力，而且这两种专业也还是有共同之处的。</p><p>但这些不是重点，我想说的是，尽管你选择的专业方向与学校课程搭配，也完全不要按着学校的培养计划来。</p><p>你要有自己的主见，根据自己的实际情况来安排每一步的学习任务。</p><p>完全跟着学校的教学进度走，你可能到最后啥都没学会，越来越懵逼迷茫。</p><p>在我看来，学校的课程只能给你当参考建议，你应该有自己的主见，关于如何去学习去然后付诸实践。</p><h2 id="3-额外能力"><a href="#3-额外能力" class="headerlink" title="3.额外能力"></a>3.额外能力</h2><p>在我看来，信息搜索能力，也是一种应当认真培养的能力。</p><p>我这里所说的信息搜索能力，不是那种利用搜索引擎进行简单的日常搜索，那只是低层面的。</p><p>很多人利用搜索引擎，可能只是简单地搜答案或者搜科普内容等。</p><p>其实搜索引擎用得好，你会发现不一样的世界。</p><p>在这之前，我希望大家先了解下常用的搜索技巧，这方面我估计大家都不知道搜东西还有技巧。</p><p>可以参考我另一篇博文<a href="https://lbihua.cn/StudyNotes/SearchSkills.html">搜索技巧</a>，图已经挂了，后期我会找时间一一补上，大家先凑合着看吧。</p><p>我希望大家能把搜索当作一种生活习惯，因为互联网的知识海洋是广袤无边的。</p><p>常用搜索引擎，你会获取到很多有用的信息，拓宽你的信息广度。</p><p>再加上你长时间的搜索，你搜索信息会更得心应手，搜索的内容会更优质，特别是搜索与学习相关的。</p><p>常用搜索引擎，你也会掌握更优质的资源，特别是对于计算机学生来说。</p><p>然而，我说这些的前提是，首先，你得有一个<strong>强大&amp;实用&amp;优秀</strong>搜索引擎。</p><p>这方面我强烈推荐谷歌搜索，关于如何使用谷歌搜索，就看你自己了(愣着干什么，赶紧去搜啊!)。</p><p>以后有什么问题或者不明白了解的地方，优先推荐使用你强大的搜索能力获取最优解。</p><p>如果实在搜不了，就去问同学或者老师吧。</p><p>但我希望你别被老师或同学这样回应：”<strong>你不会百度么？</strong>“</p><p>不用说，这是对你搜索能力的极大侮辱！！！</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前几天跟一位老朋友聊了下专业上的事，以及以后的就业选择。&lt;br&gt;她已经打算报考教资，但是以后并不打算当老师，报考教资也无非在毕业时多点人生选择。&lt;br&gt;她更愿意去互联网企业体验，所以想努力一把，然而苦于没有明确的学习方向。&lt;br&gt;由于时间限制，我们当时并没有聊太多。&lt;br&gt;但是我觉得我可以趁空写一篇博文，一来总结自己的思考经验，二来也希望对她有一定的借鉴帮助吧。&lt;br&gt;当然此文除了为那位朋友写，也是为昨晚痛哭流涕开始努力的室友写！😜&lt;br&gt;注意内容仅为个人建议，而且内容适用于计算机专业学生，实际还是以大家自身真实情况为准。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="思考" scheme="http://example.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="大学" scheme="http://example.com/tags/%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="学习方向" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>关于知识学习和公众号的思考</title>
    <link href="http://example.com/2021/06/05/Thinking/knowledge%20and%20public%20account%20/"/>
    <id>http://example.com/2021/06/05/Thinking/knowledge%20and%20public%20account%20/</id>
    <published>2021-06-05T03:47:06.057Z</published>
    <updated>2020-08-21T07:43:13.083Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="如何学习知识"><a href="#如何学习知识" class="headerlink" title="如何学习知识"></a>如何学习知识</h2><ul><li><p>系统性</p><p>学习应该是系统性的，而非碎片化的，只有系统性地学习知识才能强化记忆加深理解。</p><p>因为一个系统性的知识体系包含多个知识板块，而每个知识板块又包含多个知识。</p><p>各个知识相互联系，包括板内知识相互联系，也包括异版知识相互联系。这些知识在脑海内相互碰撞，才有了更多理解思考，同时加深记忆。</p><p>拒绝碎片化知识学习。人的记忆是有限的，而学习碎片化知识，会导致各个知识点的联系孱弱，无法引导进一步深入思考，最后导致对知识点的理解不深。</p><p>只有系统性学习了某学科的知识，才能较完整地拥有了与该学科匹配的能力。</p></li><li><p>理解性</p><p>学习应当是一个逐步深入理解的过程，而非死记硬背。</p><p>有时候理解知识比学习知识更为重要，在理解知识的过程中尽量多一些思考。</p><p>理解的知识比记忆的知识在脑海里存活得更久。</p><p>一定要在犯错的地方多思考多理解，如果再次犯错了说明还是不够理解，或者理解错误。</p></li><li><p>笔记</p><p>做笔记是为了记录自己对知识的理解，而非对知识的生硬照搬，否则只是换了个地方继续学习知识。</p><p>记录自己对知识点的理解，是为浓缩提取知识的精华，其他只是辅助的作用。</p><p>对知识的理解，时间长了也会忘记，这时候做笔记记录这些理解，回头可以温故而知新，毕竟知识常有，理解不常有。</p><p>这些知识理解笔记，也是以后最好的复习资料。</p></li></ul><h2 id="关于公众号"><a href="#关于公众号" class="headerlink" title="关于公众号"></a>关于公众号</h2><p>清理公众号，留下优质更有价值的公众号。</p><p>关于公众号里的学习资料，大部分都有推销意味以及对知识的照搬，不值得看。</p><p>而且因为知识很碎片化，远不如看一本书来得实在。</p><p>但是在查询资料的时候可以偶尔用来参考或者如果文章优质，可以用来帮助更好的理解。</p><p>别人的理解不能替代个人的理解，别人的理解也不一定能被自己彻底理解。</p><p>言归之，只有个人的主动理解思考才更有价值。</p><p>公众号更多地是扩展自己的认识广度，但是广度一定要是有价值的，而非庸俗的，比如娱乐八卦等等不值得太多关注。</p><p>更宽的广度意味着更多的解决方案。</p>]]></content>
    
    
    <summary type="html">如何更有效率学习</summary>
    
    
    
    <category term="思考" scheme="http://example.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="思考" scheme="http://example.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>关于大学生活的一点思考总结</title>
    <link href="http://example.com/2021/06/05/Thinking/About_college/"/>
    <id>http://example.com/2021/06/05/Thinking/About_college/</id>
    <published>2021-06-05T03:47:06.043Z</published>
    <updated>2020-08-22T13:43:30.949Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>以此文送给即将步入大学校园的可爱学弟学妹们，祝愿你们在大学遇到更好的伙伴，更好的师长，特别是更好的自己。</p></blockquote><p>下文是我对两年大学生活的总结思考，这其中的许多观点说不上是否绝对正确。</p><p>至少对于我个人来说是适用的，就当是提供一点经验给学弟学妹们吧~</p><span id="more"></span><h2 id="1-专业"><a href="#1-专业" class="headerlink" title="1.专业"></a>1.专业</h2><p>关于专业的选择，可能很多刚报志愿的学生，看到这么多专业，都会觉得很懵逼吧！</p><p>就算查百度，看到的也是一段官方&amp;正式&amp;专业的介绍，好了，这下更自闭迷茫了。</p><p>所以大学报专业这个事，大部分都被家长包揽了。</p><p>很少有人根据自己兴趣报专业，导致有人进了大学才发现一点儿也不喜欢这个专业，或者说学不懂~</p><p>所以我希望大家在成绩可以查询之前，最好慢慢了解一下各种专业，再根据个人兴趣选择优先专业。</p><p>可能最后发现分数不足于填报某一类专业，但是有准备总比没准备好。</p><p>了解相关专业的时候，也不用了解得很详细，有个大概了解即可。</p><p>毕竟专业这东西也得完整学习过相关课程后才能有个清晰的了解。</p><p>我希望大家能慎重对待志愿填报，因为它不但关系到以后的学习生活，更是关系到未来的职业选择。</p><p>就我亲身经历而言，我见过很多因为不喜欢个人专业而整天在大学混混沌沌过日子的人，说实话，人数真不少。</p><p>如果不慎调剂到自己不感兴趣的专业，也不用太焦虑，先学一段时间看看情况。</p><p>如果依然无法支持自己学下去，那么可以考虑换专业了。</p><p>关于换专业，我了解甚少，我只知道有的学院换专业门槛高，有的学院则比较容易。</p><p>所以换专业这个事，具体的可以问辅导员，毕竟没有比辅导员更了解情况了。</p><h2 id="2-生活"><a href="#2-生活" class="headerlink" title="2.生活"></a>2.生活</h2><p>大学的生活，怎么说呢，感觉挺戏剧性的。</p><p>忙的时候忙的要死，闲的时候闲的焦虑。</p><p>我到现在依然觉得，大学生活远没有高中生活丰富多彩，可能是我不再参加社团的原因吧？maybe😑</p><p>以前上高中的时候，总是盼望快点毕业上大学，上大学就轻松了。</p><p>现在上了大学才知道，一点儿也不轻松!!!</p><p>虽然相对高中来说更自由了，但是感觉快乐却少了更多。</p><p>所以我经常怀念高中校园的生活，怀念和班里同学相处的时光。</p><p>说实话，大学班级里的人际关系，绝大部分来说，并不是很真诚真挚。</p><p>很少有玩闹，可能是大家都成为了成熟大学生的缘故吧！🤔</p><p>扯了那么多，怕是已经打击到你们上大学的热情，敲碎了对大学的幻想吧！</p><p>啊这，我真是的，光说消极的一面了。</p><p>其实大学生活还是挺开心幸福的，我觉得因人而异吧。</p><p>这方面我就不多说了，因为你们的生活Style是由你们自己决定的。</p><p>接下来说说我对大学生活的总结，也算是小建议吧~</p><ul><li><p>无论什么时候都要保持主动和好奇心</p><p>我不是指人际关系方面，而是对<code>生活保持积极进取，乐于探索很多相对于个人来说未知的东西</code>。</p><p>大学是拓宽眼界的开始，所以请各位要好好把握机会。</p><p>等毕业出来开始进入社会后，相信你的格局会比很多人大得多。</p><p>否则，会成为在学校或者寝室生活的井底之蛙。</p></li><li><p>远离腐烂的生活，过精致的每一天</p><p>虽说在大学学习腐烂生活是少不了，偶尔的腐烂生活也是可以的，但绝对不能长期如此。</p><p>否则一旦养成了腐烂的生活习惯，死不悔改，那么在大学你个人算是颓废掉了。</p><p>我希望小学弟学妹们在大学生活时，一定要有规律的生活，也有点规则。</p><p>可以试试每天给自己安排一系列任务。</p><p>比如去图书馆看书，抑或晚上去跑步，也抑或和同学在外面逛街等等。</p><p>特别是养成每周锻炼身体的习惯，也不要天天熬夜，别问为什么，美好精致的一天以元气满满开始，奥利给！🏃‍♂️</p><p>总之不要一整天都待在寝室刷剧刷抖音，特别是各类短视频应用，对于我个人而言，那简直就是精神鸦片。</p></li></ul><h2 id="3-学习"><a href="#3-学习" class="headerlink" title="3.学习"></a>3.学习</h2><blockquote><p>衡量一个大学生是否优秀的重要指标之一，就是是否具备足够的自学能力。</p></blockquote><p>我希望，无论怎么样，大家都能把学习当作重要的事情去做，也时时刻刻放在心里很重要的位置。</p><p>可能大家上了大学，就彻底放飞自我了，以为大学是来玩的。</p><p>然而并非如此，大学的学习任务其实是很艰辛的，如果你认真对待。</p><p>这么说吧，如果你对学习随便敷衍了事，半小时左右你可以完成所有的学习任务。</p><p>如果你认真起来，可能你会经常熬夜完成学习任务，不过这种情况通常来说不常发生 。</p><p>然而我希望你还是要明白，上大学只是比以前更自由了，但学习依然是你进入大学的第一任务。</p><p>我希望大家能平衡好娱乐与学习之间的时间，娱乐很重要，但学习也很重要，<code>会玩才会学</code>。</p><p>但对于我个人而言，我觉得我进入大学<code>不是为了学习而学习</code>，相反我是为<code>培养专业能力</code>而学习。</p><p>很多人学习可能只是为了奖学金，可能是为了考试及格，也可能是为了以后找工作。</p><p>但我希望大家任何学习任务的展开，都是以培养增强专业能力为重，这才是我们上大学的根本原因。</p><p>上了大学你会接触到各种形形色色的课，有些无关紧要的课，如果你不感兴趣，可以不听。</p><p>但是结课考时尽量别挂科，并且在上课时也可以学点其他东西，少玩手机。</p><p>为什么不要挂科?</p><ul><li>影响奖学金评估</li><li>对考研也会有一点影响</li><li>可能影响取得学士学位证</li><li>如果挂科了，会有补考，但如果补考没过，那就要重修了，怎么说，时间成本挺大的</li><li>等等</li></ul><p>还有最重要的一点，<code>学习应该是自觉的，也是主动的</code>。</p><p>怎么学习，怎么安排学习任务，什么时候开始学习，完全是根据来个人情况而定的。</p><p>你总不能看到你室友开始学习你就立马学习吧，等你室友开始放松的时候你也开始放松。</p><p>这一点不同于高中，高中学习差不多是被动的，你的学习任务时时刻刻有人监督。</p><p>但大学就一样了，学习全靠自觉，老师也不会怎么监督你，很宽松。</p><p>所以，我希望你在大学开始培养自主学习的能力，也就是自学的能力。</p><p>等你走上社会后，你也会感谢当初在大学培养的自学能力，真的！</p><p>为什么?因为你上班了可能还是得继续学习！</p><h2 id="社团"><a href="#社团" class="headerlink" title="社团"></a>社团</h2><p>社团这方面，我不是很了解。</p><p>我在大学好像也报过三种社团，后来慢慢地每个社团就不怎么去了。</p><p>直到大一下学期才终于”自由”了，不再参加所有社团活动。</p><p>其实不再参加社团活动也不是因为不再感兴趣的原因。</p><p>怎么说呢，也是有很多事综合起来的原因。</p><p>但是我觉得我还是有一点看法来告诉你们：</p><p>我觉得吧，社团如果不是自己感兴趣，还是少报点为好，因为到了后面你会觉得越来越累，力不从心，还会严重影响到学习任务。</p><p>所以如果可以，最好报一个就足够了，你其实是没那么多时间的。</p><p>如果某一个社团能让你学习到很多东西，从长远来说也有一定的价值意义，那么我希望你能长期坚持下去。</p><hr><p>我觉得全文最后可以浓缩成一句话:</p><p><code>不要让大学上了你，而要自己上了大学</code></p><p>最后祝各位有一段<strong>奇妙无比&amp;快乐潇洒&amp;无与伦比</strong>的大学经历！<br>也算是对我的个人祝愿。<br>愿共勉！💪</p><p>​                    </p>]]></content>
    
    
    <summary type="html">长文预警，请慢些阅读！</summary>
    
    
    
    <category term="思考" scheme="http://example.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="大学" scheme="http://example.com/tags/%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="思考" scheme="http://example.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>SQL总结</title>
    <link href="http://example.com/2021/06/05/studynotes/sql/"/>
    <id>http://example.com/2021/06/05/studynotes/sql/</id>
    <published>2021-06-05T03:47:06.029Z</published>
    <updated>2020-10-06T12:03:15.620Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>文本记录了自己学习SQL时的一些知识点总结。</p><p>学习于<a href="https://www.liaoxuefeng.com/wiki/1177760294764384">廖雪峰的SQL教程</a></p></blockquote><span id="more"></span><h3 id="SQL概述"><a href="#SQL概述" class="headerlink" title="SQL概述"></a>SQL概述</h3><ul><li>SQL是一种访问和处理关系数据库的计算机标准语言。</li><li>SQL即<code>Structured Query Language</code>,中文全称为结构化查询语言。</li><li><code>NoSQL</code>数据库，也就是非SQL的数据库，现在它与SQL数据库的关系为主从关系。</li><li>NoSQL数据库有<code>MongoDB</code>、<code>Cassandra</code>、<code>Dynamo</code>等等。</li><li>SQL语言的几种功能<ul><li>DDL:<code> Data Definition Language</code>定义数据的功能，即创建表，删除表，更新表等操作。</li><li>DML:<code>Data Manipulation Language</code>添加，删除，更新数据等操作。</li><li>DQL:<code>Data Query Language</code>查询数据的操作。</li></ul></li></ul><h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><ul><li>数据库是一种管理数据的软件，应用程序可以通过数据库软件提供的接口来读写数据。</li><li>数据模型:数据库按照数据结构来组织、存储和管理数据。<ul><li>层次模型:按上下级的层次关系来组织数据。</li><li>网状模型:把每个数据节点与其他数据节点连接起来。</li><li>关系模型:类似于<code>excel</code>表。</li></ul></li><li>最普遍使用的数据模型是关系模型，因为易于理解&amp;使用简单。</li></ul><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><ul><li>关系模型本质上是若干个存储数据的二维表。</li><li></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;文本记录了自己学习SQL时的一些知识点总结。&lt;/p&gt;
&lt;p&gt;学习于&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/1177760294764384&quot;&gt;廖雪峰的SQL教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="技术笔记" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="SQL" scheme="http://example.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>语义化版本2.0.0介绍</title>
    <link href="http://example.com/2021/06/05/studynotes/semver2.0.0/"/>
    <id>http://example.com/2021/06/05/studynotes/semver2.0.0/</id>
    <published>2021-06-05T03:47:06.018Z</published>
    <updated>2020-08-24T02:15:32.339Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="语义化版本2-0-0介绍"><a href="#语义化版本2-0-0介绍" class="headerlink" title="语义化版本2.0.0介绍"></a>语义化版本2.0.0介绍</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>语义化版本是为了解决软件开发过程中依赖关系混乱或者依赖锁死的情况。</p><p>它的标准格式如下：</p><blockquote><p><strong>x.y.z</strong></p></blockquote><p>其中x表示主版本号，y表示次版本号，z表示修订号。</p><p>对这几种版本号的解释如下：</p><p>X 主版本号，表示做了<strong>不向下兼容的修改</strong>时递增。</p><p>Y 次版本号，表示做了<strong>向下兼容的新增及修改</strong>时递增。</p><p>Z 修订号，表示做了<strong>向下兼容的问题修复</strong>时递增。</p><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><ol><li><p>必须定义公共API，且公共API应该力求准确和完整。</p></li><li><p>x,y,z必须都为非负整数，且禁止在数字前补零。</p></li><li><p>0.y.z表示软件处于初始开发阶段,y与z可以根据初始开发阶段的情况递增。</p></li><li><p>1.0.0表示软件开发成功的第一个版本号，也是界定公共API成熟的标志。</p></li><li><p>次版本号递增的原则:</p><ul><li>新功能添加时。</li><li>某一功能被弃用时。</li><li>某一功能被改进时。(其中可包括修订级别的改变)</li><li>次版本号递增时，修订号必须归零。</li></ul></li><li><p>主版本号递增时，次版本号和修订号必须清零，其中可包括次版本号和修订号的改变。</p></li><li><p>先行版本号添加原则:</p><ul><li>由连接号和描述符组成。</li><li>添加在修订号后面。</li><li>先行版本号表示这个版本并非稳定并有非兼容情况出现。</li><li>优先级低于相关联的标准版本号。</li></ul></li><li><p>版本编译元数据添加原则:</p><ul><li>由加号和描述符组成。</li><li>添加在修订号或者先行版本号后面。</li><li>版本编译元数据不参与版本优先级比较。</li></ul></li><li><p>优先级比较原则:一一拆分为各种版本号比较。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文章内容参考于<a href="https://semver.org/lang/zh-CN/#spec-item-9%E3%80%82">https://semver.org/lang/zh-CN/#spec-item-9。</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="扩展阅读" scheme="http://example.com/categories/%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="版本号" scheme="http://example.com/tags/%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>搜索技巧</title>
    <link href="http://example.com/2021/06/05/studynotes/SearchSkills/"/>
    <id>http://example.com/2021/06/05/studynotes/SearchSkills/</id>
    <published>2021-06-05T03:47:06.005Z</published>
    <updated>2020-08-24T02:15:44.231Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>本期歌曲推荐《白兰鸽巡游记》</strong></p><p>“<em>年少时总是向往南方，直到青丝暮成雪的那天，才发现南方和我都是相逢一笑过客，同白兰鸽在一个安静的早晨飞回北方吧，那里冬天的寒风再怎样刺骨，可那是我的故乡啊</em>“——网易云音乐热评.</p><h1 id="1-关键词搜索"><a href="#1-关键词搜索" class="headerlink" title="1.关键词搜索"></a>1.关键词搜索</h1><blockquote><p>加双引号” “ 搜索法，有时候当我们搜索查找某个关键词时，加上双引号浏览器会返回与关键词相匹配吻合的结果，这样会极大提高搜索结果的准确性,详见下图。</p></blockquote><p><img src="https://imgkr.cn-bj.ufileos.com/9d4925ba-87de-4b33-8db7-7149b07465bd.png"></p><blockquote><p>2.排除搜索<br>加减号法，在搜索时，如果不想看到浏览器返回的某些结果，可使用减号来排除不想看到的关键词。比如搜索时，排除百度返回的结果，如下图。<br>​</p></blockquote><p><img src="https://imgkr.cn-bj.ufileos.com/fea8cea0-f05b-47c6-9ab9-45c7c908c6b4.png"></p><blockquote><p>3.同义词搜索<br>加波浪线符号搜索法，当未能准确确定要搜索的关键词时 可以用 ~ 进行同义词搜索。</p></blockquote><p><img src="https://imgkr.cn-bj.ufileos.com/db0c4673-78f9-4a7b-b1b0-fba22aa9bb47.png"></p><blockquote><p>4.星号搜索<br>加星号搜索法，当忘记了搜索关键词的某些部分时，可使用 * 替代，这个星号可以表示任何字符，非常强大，特别是搜歌名时就很有用。</p></blockquote><p><img src="https://imgkr.cn-bj.ufileos.com/a5404cd8-0833-4cd2-88af-1cdbf261d8f7.png"></p><blockquote><p>5.站内搜索<br>在输入框内输入这样的格式 site:网址 关键词 会返回某个网站的搜索结果。</p></blockquote><p><img src="https://imgkr.cn-bj.ufileos.com/5c7173ac-058f-4e8f-a7d3-69e7cbc0fa69.png"></p><blockquote><p>6.文件类型搜索<br>文件名 filetype:文件类型，当你想寻找pdf,ppt，excel类型的文件时，这样的搜索格式就非常有用了，搜索时会更有针对性地搜索，节约了大把时间寻找文件。</p></blockquote><p><img src="https://imgkr.cn-bj.ufileos.com/2a6673eb-2edc-40ab-a37c-d856cfff571d.png"></p>]]></content>
    
    
    <summary type="html">培养搜索的能力~</summary>
    
    
    
    <category term="扩展阅读" scheme="http://example.com/categories/%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="sources" scheme="http://example.com/tags/sources/"/>
    
  </entry>
  
  <entry>
    <title>npm常用命令</title>
    <link href="http://example.com/2021/06/05/studynotes/npm-command/"/>
    <id>http://example.com/2021/06/05/studynotes/npm-command/</id>
    <published>2021-06-05T03:47:05.995Z</published>
    <updated>2020-08-24T02:01:03.397Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="npm常见命令"><a href="#npm常见命令" class="headerlink" title="npm常见命令"></a>npm常见命令</h1><h2 id="一-npm-amp-yarn介绍"><a href="#一-npm-amp-yarn介绍" class="headerlink" title="一.npm&amp;yarn介绍"></a>一.npm&amp;yarn介绍</h2><p>npm是一个基于Node.js的包管理工具。<br>yarn是Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 包管理工具,与npm相比有些优势。<br>npm在安装Node.js时会被一并安装，yarn则需要额外安装。</p><h2 id="二-npm-amp-cnpm的关系"><a href="#二-npm-amp-cnpm的关系" class="headerlink" title="二.npm&amp;cnpm的关系"></a>二.npm&amp;cnpm的关系</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>由于npm服务器在国外，所以在国内安装速度不是很理想，于是淘宝团队开发了一个npmjs.org的镜像，可以有效解决下载过于缓慢的问题。这是淘宝团队对它的介绍。</p><blockquote><blockquote><p>“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。”</p></blockquote></blockquote><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="三-npm常见命令"><a href="#三-npm常见命令" class="headerlink" title="三.npm常见命令"></a>三.npm常见命令</h2><h3 id="1-npm-v"><a href="#1-npm-v" class="headerlink" title="1.npm -v"></a>1.npm -v</h3><p>查看npm版本信息。</p><h3 id="2-npm-install-lt-Module-Name-gt-本地安装"><a href="#2-npm-install-lt-Module-Name-gt-本地安装" class="headerlink" title="2.npm install  &lt; Module Name &gt; 本地安装"></a>2.npm install  &lt; Module Name &gt; 本地安装</h3><p>在本地目录的node_modules下安装模块。</p><h3 id="3-npm-install-lt-Module-Name-gt-g-全局安装"><a href="#3-npm-install-lt-Module-Name-gt-g-全局安装" class="headerlink" title="3.npm install &lt; Module Name &gt;  -g 全局安装"></a>3.npm install &lt; Module Name &gt;  -g 全局安装</h3><p>将模块安装在node所安装的目录。</p><h3 id="4-npm-list-g"><a href="#4-npm-list-g" class="headerlink" title="4.npm list -g"></a>4.npm list -g</h3><p>查看全局安装的模块。</p><h3 id="5-npm-list-lt-Module-Name-gt"><a href="#5-npm-list-lt-Module-Name-gt" class="headerlink" title="5.npm list &lt; Module Name &gt;"></a>5.npm list &lt; Module Name &gt;</h3><p>查看模块的版本信息。</p><h3 id="6-npm-uninstall-lt-Module-Name-gt"><a href="#6-npm-uninstall-lt-Module-Name-gt" class="headerlink" title="6.npm uninstall &lt; Module Name &gt;"></a>6.npm uninstall &lt; Module Name &gt;</h3><p>卸载模块。</p><h3 id="7-npm-update-lt-Module-Name-gt"><a href="#7-npm-update-lt-Module-Name-gt" class="headerlink" title="7.npm update  &lt; Module Name &gt;"></a>7.npm update  &lt; Module Name &gt;</h3><p>更新模块。</p><h3 id="8-npm-search-lt-Module-Name-gt"><a href="#8-npm-search-lt-Module-Name-gt" class="headerlink" title="8.npm search  &lt; Module Name &gt;"></a>8.npm search  &lt; Module Name &gt;</h3><p>搜索模块。</p><h3 id="9-npm-init"><a href="#9-npm-init" class="headerlink" title="9.npm init"></a>9.npm init</h3><p>初始化创建模块</p><h3 id="10-npm-adduser"><a href="#10-npm-adduser" class="headerlink" title="10.npm adduser"></a>10.npm adduser</h3><p>在某个资源库中注册账号。</p><h3 id="11-npm-pulish"><a href="#11-npm-pulish" class="headerlink" title="11.npm pulish"></a>11.npm pulish</h3><p>推送模块到库。</p><h2 id="四-nrm包介绍"><a href="#四-nrm包介绍" class="headerlink" title="四.nrm包介绍"></a>四.nrm包介绍</h2><h3 id="1-nrm是一个源管理工具，利用它可以切换下载源。"><a href="#1-nrm是一个源管理工具，利用它可以切换下载源。" class="headerlink" title="1.nrm是一个源管理工具，利用它可以切换下载源。"></a>1.nrm是一个源管理工具，利用它可以切换下载源。</h3><h3 id="2-安装-1"><a href="#2-安装-1" class="headerlink" title="2.安装"></a>2.安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g nrm</span><br></pre></td></tr></table></figure><h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h3><h4 id="1-nrm-ls"><a href="#1-nrm-ls" class="headerlink" title="1.nrm ls"></a>1.nrm ls</h4><p>列出所有的源。</p><h4 id="2-nrm-test"><a href="#2-nrm-test" class="headerlink" title="2.nrm test"></a>2.nrm test</h4><p>测试每个源的速度。</p><h4 id="3-nrm-use-lt-registry-gt"><a href="#3-nrm-use-lt-registry-gt" class="headerlink" title="3.nrm use &lt; registry &gt;"></a>3.nrm use &lt; registry &gt;</h4><p>切换npm源。</p><h4 id="4-nrm-add-lt-registry-gt-lt-url-gt"><a href="#4-nrm-add-lt-registry-gt-lt-url-gt" class="headerlink" title="4.nrm add &lt; registry &gt;  &lt; url &gt;"></a>4.nrm add &lt; registry &gt;  &lt; url &gt;</h4><p>增加npm源。</p><h4 id="5-nrm-del-lt-registry-gt"><a href="#5-nrm-del-lt-registry-gt" class="headerlink" title="5.nrm del &lt; registry &gt;"></a>5.nrm del &lt; registry &gt;</h4><p>删除源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技术笔记" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="npm" scheme="http://example.com/tags/npm/"/>
    
    <category term="yarn" scheme="http://example.com/tags/yarn/"/>
    
    <category term="cnpm" scheme="http://example.com/tags/cnpm/"/>
    
  </entry>
  
  <entry>
    <title>Markdown</title>
    <link href="http://example.com/2021/06/05/studynotes/Markdown%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2021/06/05/studynotes/Markdown%E8%AF%AD%E6%B3%95/</id>
    <published>2021-06-05T03:47:05.985Z</published>
    <updated>2020-08-24T02:00:55.714Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Markdown介绍"><a href="#Markdown介绍" class="headerlink" title="Markdown介绍"></a>Markdown介绍</h1><p>什么是Markdown?它是一种轻量级的文本标记语言，使用它可以更方便地编辑文档。</p><p>很多网站都利用它来撰写文档或用于在论坛发消息等等。</p><p>说到这大家可能就像在听天书一样，因为搞不懂专业用语。  </p><p> 事实上这并不是什么计算机编程语言，而是通用的普通人都可以学的标记语言，贱简单呐。</p><p>在讲解常见的Markdown语法之前，我先向大家介绍一下富文本编辑器。</p><p>富文本编辑器其实很常见的，比如Word，WPS的编辑页面就是一种富文本文本编辑器。</p><p>那么它与支持Markdown语法的编辑器有何不同？</p><p>最大的区别在于：富文本编辑器对文本内容的编辑，大多是通过键盘快捷键或者点击编辑按钮比如加粗，斜体，标题设置等来编辑的。</p><p>Markdown编辑器就不一样了，在这里举个例子，如果要设置一级标题，应该怎么处理呢？</p><p>很简单 ，在开头打一个#号就可以了，比如 # 这是一级标题(注意#号留有一个空格)，那么二级标题呢？so easy，在开头打两个#号就可以了。</p><p>是不是很简单？所以学习Markdown语法，并不需要太费脑费劲，只需要记住大部分常用的语法格式即可。</p><p>下面是我总结的使用Markdown语法编写文章的好处：</p><blockquote><ul><li>沉浸式写作，完全不会太分心，不用再点击鼠标或者敲键盘编辑文章了。  </li><li>方便快捷，只需掌握常用语法，即可应付常见格式要求。</li><li>支持多类型文章的导入导出，比如Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</li></ul></blockquote><p>平时写文章或者论文什么的，可以用markdown语法.让你全神贯注一心一意扑在写文章大业上，何乐而不为？</p><p>如果你问我有什么好的Markdown编辑器，那我绝对强烈推荐你用Tlianjie ypora。</p><p>为什么呢，你可以点击这篇文章详细了解。接下来不多说，开始迎接主角。</p><h1 id="常用markdown语法"><a href="#常用markdown语法" class="headerlink" title="常用markdown语法"></a>常用markdown语法</h1><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><blockquote><p>使用 # 可标记标题，其中#号的个数表示标题级别，最高级别是一级标题，最多支持6级标题。</p></blockquote><p><img src="https://gitee.com/liubeep/blogimage/raw/master/img/20200618220309.gif" alt="img"></p><h3 id="2-字体"><a href="#2-字体" class="headerlink" title="2.字体"></a>2.字体</h3><blockquote><ol><li><p>斜体文字可用 *   * 表示。</p></li><li><p> 粗体文字可用 **   **表示。</p></li><li><p>粗斜体文字可用 ***   ***   表示</p><p>其中*号也可用  _代替。</p></li></ol></blockquote><p><img src="https://gitee.com/liubeep/blogimage/raw/master/img/20200618221239.gif" alt="img"></p><h3 id="3-分割线"><a href="#3-分割线" class="headerlink" title="3.分割线"></a>3.分割线</h3><blockquote><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线。  </p></blockquote><p><img src="https://gitee.com/liubeep/blogimage/raw/master/img/20200618222113.png" alt="image-20200618222113712"></p><p><img src="https://gitee.com/liubeep/blogimage/raw/master/img/20200618222130.png" alt="image-20200618222130364"></p><h3 id="4-删除线"><a href="#4-删除线" class="headerlink" title="4.删除线"></a>4.删除线</h3><blockquote><p>文字的两端加上两个波浪线 <strong>~~</strong> ,可为文字添加删除线。</p></blockquote><h3 id="5-下划线"><a href="#5-下划线" class="headerlink" title="5.下划线"></a>5.下划线</h3><blockquote><p>文字的左端添加 <u>  ,右端添加 </u> ,可为文字添加下划线</p></blockquote><h3 id="6-脚注"><a href="#6-脚注" class="headerlink" title="6.脚注"></a>6.脚注</h3><blockquote><p>脚注是对文本的补充说明,它的格式为[^ ]</p></blockquote><p><img src="https://gitee.com/liubeep/blogimage/raw/master/img/20200618223524.png" alt="image-20200618223524031"></p><p><img src="https://gitee.com/liubeep/blogimage/raw/master/img/20200618223604.png" alt="image-20200618223604320"></p><h3 id="7-无序列表"><a href="#7-无序列表" class="headerlink" title="7.无序列表"></a>7.无序列表</h3><blockquote><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容。</p></blockquote><p><img src="https://gitee.com/liubeep/blogimage/raw/master/img/20200618224001.png" alt="image-20200618224000932"></p><p><img src="https://gitee.com/liubeep/blogimage/raw/master/img/20200618224016.png" alt="image-20200618224016288"></p><h3 id="8-有序列表"><a href="#8-有序列表" class="headerlink" title="8.有序列表"></a>8.有序列表</h3><blockquote><p>有序列表使用数字并加上 . 号来表示.</p></blockquote><h3 id="9-链接"><a href="#9-链接" class="headerlink" title="9.链接"></a>9.链接</h3><blockquote><p>Markdown表示链接有两种方式：</p><ol><li>[链接名称] (链接地址)</li><li>&lt;链接地址&gt;</li></ol></blockquote><p>例如：</p><p><img src="https://gitee.com/liubeep/blogimage/raw/master/img/20200618225431.png" alt="image-20200618225431027"></p><p>结果：</p><p><img src="https://gitee.com/liubeep/blogimage/raw/master/img/20200618225516.png" alt="image-20200618225516215"></p><h3 id="10-图片"><a href="#10-图片" class="headerlink" title="10.图片"></a>10.图片</h3><blockquote><ul><li>开头一个感叹号</li><li>接着一个方括号，里面写明对图片的描述。</li><li>最后一个普通括号，里面是图片的链接。</li></ul></blockquote><p>实例：</p><p><img src="https://gitee.com/liubeep/blogimage/raw/master/img/20200618230312.png" alt="image-20200618230312484"></p><p>结果：</p><p><img src="https://gitee.com/liubeep/blogimage/raw/master/img/20200618230343.png" alt="image-20200618230343812"></p><h3 id="11-表格"><a href="#11-表格" class="headerlink" title="11.表格"></a>11.表格</h3><blockquote><ul><li>Markdown使用 | 来分隔单元格，使用 - - - 来分隔表头和其他行。</li><li>-：设置内容和标题居右对齐。</li><li>:-  设置内容和标题居左对齐。</li><li>:-: 设置内容和标题居中对齐。</li></ul></blockquote><p>实例：</p><p><img src="https://gitee.com/liubeep/blogimage/raw/master/img/20200619071549.png" alt="image-20200619071549100"></p><p>结果：</p><p><img src="https://gitee.com/liubeep/blogimage/raw/master/img/20200619071637.png" alt="image-20200619071637459"></p><p>另外，数学公式也可以用Markdown语法编写，但是有些复杂复杂，而且我们平时也不会经常用到，所以就不介绍了。</p>]]></content>
    
    
    <summary type="html">Markdown语法介绍</summary>
    
    
    
    <category term="技术笔记" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Markdown" scheme="http://example.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Java反射</title>
    <link href="http://example.com/2021/06/05/studynotes/java-reflection/"/>
    <id>http://example.com/2021/06/05/studynotes/java-reflection/</id>
    <published>2021-06-05T03:47:05.978Z</published>
    <updated>2020-10-23T03:54:37.802Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文是Java反射篇，学习于<a href="https://www.liaoxuefeng.com/wiki/1252599548343744">廖雪峰的Java教程</a></p></blockquote><h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><h3 id="1-Class类"><a href="#1-Class类" class="headerlink" title="1.Class类"></a>1.Class类</h3><ul><li><p>反射：通过<code>Class</code>实例获取相关类信息的方法称为反射。</p></li><li><p><code>JVM</code>会在执行过程中动态加载类到内存，并为其创建一个<code>Class</code>类型的实例，并且该Class实例只能在JVM内部创建。</p></li><li><p>如何获取一个<code>Class</code>实例</p><ul><li>通过一个类的静态变量<code>class</code>获取，如<code>String.class</code>。</li><li>通过实例变量调用<code>getClass()</code>方法。</li><li>通过<code>Class</code>类的静态<code>Class.forName()</code>方法，例<code>Class.forName(String.lang.String)</code>,其中参数中的类名要为完整类名。</li></ul></li><li><p><code>Class</code>实例的比较，可以用<code>==</code>比较，原因是<code>Class</code>实例在JVM中是唯一的。</p></li><li><p>准确判断两个类型是否为同一类型可用<code>==</code>比较。</p></li><li><p>数组例如<code>String[ ]</code>也可以创建<code>Class</code>实例，而且不同于<code>String.class</code>。</p></li><li><p>此外，<code>JVM</code>也为基本类型创建了<code>Class</code>实例,例如<code>int.class</code>。</p></li><li><p>可通过一个<code>Class</code>实例调用<code>newInstance()</code>方法创建一个对应类型的实例，但只能调用该类的无参数构造方法，例如:</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class cls = String.class;</span><br><span class="line">String s = (String) cls.newInstance();</span><br></pre></td></tr></table></figure><ul><li><code>JVM</code>的动态加载:JVM在执行Java程序的时候，并不会一次性加载所有class到内存，而是会优先把首先用到的class加载进内存，尚未需要的class并不会被加载。</li></ul><h3 id="2-Field实例"><a href="#2-Field实例" class="headerlink" title="2.Field实例"></a>2.Field实例</h3><ul><li><p>获取<code>Filed</code>实例</p><ul><li><code>Field getField(name)</code>参数为字段名，获取<code>public</code>实例字段，包括父类。</li><li><code>Filed getDeclaredField(name)</code>参数为字段名，只获取当前类的所有Field实例字段。</li><li><code>Field[] getFields()</code>获取所有<code>public</code>实例字段，包括父类。</li><li><code>Field[] getDeclaredFields()</code>只获取当前类的所有<code>public</code>实例字段。</li></ul></li><li><p>Field实例包含的几个方法</p><ul><li><code>getName()</code>获取字段名称。</li><li><code>getType()</code>获取字段类型。</li><li><code>getModifiers()</code>获取字段修饰符，会返回一个<code>int</code>类型的数值，最后再通过静态<code>Modifier.isPublic()</code>等方法判断是否为<code>public</code> 等修饰符。</li></ul></li><li><p>获取字段的值可通过Field实例调用<code>get(p)</code>方法来获取字段的值，其中参数p为原类型实例。</p></li><li><p><code>setAccesible(true)</code>方法可以设置某非<code>public</code>字段的值可访问。</p></li><li><p><code>set(Object,Objie)</code>方法可用来设置字段的值，其中第一个参数为原类型实例，第二个参数为待修改的值。</p></li><li><p>示例代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        f.set(p, <span class="string">&quot;Xiao Hong&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Hong&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-Method实例"><a href="#3-Method实例" class="headerlink" title="3.Method实例"></a>3.Method实例</h3><ul><li><p>获取<code>Method</code>实例</p><ul><li><code>Method getMethod(name,Class)</code>，第一个参数为原类型实例，第二个参数为方法名<code>name</code>的参数的数据类型所对应的Class实例，获取public实例方法(包括父类)。</li><li><code>Method getDeclaredMethod(name, Class...)</code>只获取当前类的实例方法。</li><li><code>Method[] getMethod()</code>获取所有<code>public</code>实例方法(包括父类)。</li><li><code>Method[] getDeclaredMethod()</code>只获取当前类的所有实例方法。</li></ul></li><li><p><code>Method</code>实例包含的几个方法</p><ul><li><code>getName()</code>获取方法名字。</li><li><code>getReturnTyoe()</code>获取方法的返回类型。</li><li><code>getParameterTypes()</code>获取方法的参数类型，是一个Class数组。</li><li><code>getModifies()</code>获取方法的修饰符。</li><li><code>invoke()</code>方法相当于调用该实例方法,第一个参数为调用该方法的实例，并且参数要与实例方法参数一致。</li></ul></li><li><p><code>setAccesible(true)</code>可设置某非<code>public</code>方法可访问。</p></li><li><p>通过反射调用方法时，仍然遵循多态原则。</p></li></ul><h3 id="4-Constructor实例"><a href="#4-Constructor实例" class="headerlink" title="4.Constructor实例"></a>4.Constructor实例</h3><ul><li>获取<code>Constructor</code>实例<ul><li><code>Constructor getConstructor()</code>获取当前类的某个public构造方法。</li><li><code>Constructor getDeclaredConstructor()</code>获取当前类的某个构造方法。</li><li><code>Constructor[] getConstructor()</code>获取当前类的所有<code>public</code>构造方法。</li><li><code>Constructor[] getConstructor()</code>获取当前类的所有<code>public</code>构造方法。</li></ul></li><li><code>Constructo</code>实例可以调用拥有多种参数的构造方法。</li><li>设置<code>setAccessible(true)</code>来访问非<code>public</code>构造方法。</li><li>代码示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        Constructor cons1 = Integer.class.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        Integer n1 = (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">        Constructor cons2 = Integer.class.getConstructor(String.class);</span><br><span class="line">        Integer n2 = (Integer) cons2.newInstance(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-反射与继承关系"><a href="#5-反射与继承关系" class="headerlink" title="5.反射与继承关系"></a>5.反射与继承关系</h3><ul><li><code>getSuperClass()</code>方法可以获取子类的父类。</li><li><code>getInterfaces()</code>方法可以获取子类实现的接口类，注意这个方法的返回类型是<code>Class[]</code>数组,也只能获取当前类的接口，不包括父类。</li><li><code>isAssignableForm()</code>方法可以判断两个Class实例向上转型是否成功。</li></ul><h3 id="6-动态代理"><a href="#6-动态代理" class="headerlink" title="6.动态代理"></a>6.动态代理</h3><ul><li>动态代理：能够在运行期动态创建接口对象的方式叫做动态代理。</li><li>如何实现动态代理<ul><li>定义<code>InvocationHandler</code>实例，用来负责实现接口的方法调用。</li><li>通过<code>Proxy.newProxyInstance()</code>创建接口实例，它有三个参数<ul><li>接口类的<code>ClassLoader</code>，可通过<code>getClassLoader()</code>获取。</li><li>接口数组。</li><li>用来实现接口方法调用的<code>InvocationHandler</code>实例。</li></ul></li><li>将返回的Object类型实例强制转换为接口类型。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">Java进阶学习之反射</summary>
    
    
    
    <category term="技术笔记" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="Java反射" scheme="http://example.com/tags/Java%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Java面向对象基础</title>
    <link href="http://example.com/2021/06/05/studynotes/java-object-oriented/"/>
    <id>http://example.com/2021/06/05/studynotes/java-object-oriented/</id>
    <published>2021-06-05T03:47:05.967Z</published>
    <updated>2020-09-29T13:05:12.191Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文是Java的面向对象篇，学习于<a href="https://www.liaoxuefeng.com/">廖雪峰的Java教程</a>.</p></blockquote><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="1-方法"><a href="#1-方法" class="headerlink" title="1.方法"></a>1.方法</h3><ul><li><code>private</code>方法和<code>private</code>字段不能外部类访问。</li><li><code>private</code>方法和<code>private</code>字段是用来方便自身类使用的，为了保证类的封装性。</li><li><strong>this</strong> 变量指当前实例。</li><li>局部变量的优先级高于字段，可变参数也是局部变量。</li><li>可变参数的定义：<code>类型... 变量名</code>，相当于数组。</li></ul><h3 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2.构造方法"></a>2.构造方法</h3><ul><li>构造方法名与类名相同，构造方法无返回值，必须用<code>new</code>操作符调用。</li><li>未自定义构造方法时，系统会默认创建一个无参数构造方法。</li><li>如果已经自定义构造方法，系统将不再默认创建构造方法。</li><li>引用类型的字段默认是<code>null</code>，数值类型的字段是默认值，<code>int</code>类型默认值是<code>0</code>，布尔类型默认值是<code>false</code>。</li><li>字段的最终赋值结果由构造方法中的赋值语句决定。</li><li>一个类中可以有多构造方法，只是参数列表不同。</li></ul><h3 id="3-重载方法"><a href="#3-重载方法" class="headerlink" title="3.重载方法"></a>3.重载方法</h3><ul><li>方法名相同但参数列表不同的方法叫(overload)重载方法，返回类型<strong>通常</strong>是相同的。</li><li>重载方法的目的是实现相似的功能但得出不同的结果。</li><li>方法签名: 方法名和参数列表。</li></ul><h3 id="4-继承"><a href="#4-继承" class="headerlink" title="4.继承"></a>4.继承</h3><ul><li>继承是面向对象编程中的一种强大机制，它明显的功能就是实现代码复用。</li><li>可以用<code>extends</code> 关键字来实现继承。</li><li>一个类只能继承自一个父类，但一个类可以同时被多个类继承。</li><li>未用关键字<code>extends</code>声明继承关系的类，默认 <code>extends Object</code>.</li><li>用<code>protected</code>声明的字段和方法可以被继承树内的子类访问。</li><li><code>super</code>表示父类(超类)</li><li>在任何类的构造方法中，第一行必须是父类的构造方法。</li><li>如无明显地调用父类的构造方法，编译器会生成默认无参数的调用父类的构造方法。</li><li>如果明显地调用了父类的构造方法，编译器将不再生成默认构造方法。</li></ul><h3 id="4-向上转型-amp-向下转型"><a href="#4-向上转型-amp-向下转型" class="headerlink" title="4.向上转型&amp;向下转型"></a>4.向上转型&amp;向下转型</h3><ul><li>向上转型:将一个子类类型转变为父类类型。</li><li>向下转些:将一个父类类型转变为子类类型。</li><li>向下转型可能会失败，失败时会报<code>ClassCastException</code>错误。</li><li><code>instanceof</code>可以判断一个变量的类型是否是指定类型或者指定类型的子类。</li><li>继承是<strong>is</strong>关系，组合是<strong>has</strong>关系，组合是指某个类有另一个类的实例，但这两个类没有继承关系。</li></ul><h3 id="5-覆写方法"><a href="#5-覆写方法" class="headerlink" title="5.覆写方法"></a>5.覆写方法</h3><ul><li><p>方法签名相同的方法，叫覆写方法(override)。</p></li><li><p>重载方法和覆写方法的区别</p></li></ul><table><thead><tr><th align="left">比较</th><th align="center">重载</th><th align="center">覆写</th></tr></thead><tbody><tr><td align="left">方法名</td><td align="center">相同</td><td align="center">相同</td></tr><tr><td align="left">参数列表</td><td align="center">不同</td><td align="center">相同</td></tr><tr><td align="left">返回类型</td><td align="center">一般相同</td><td align="center">相同</td></tr></tbody></table><ul><li>覆写方法前加上@Override可以让编译器帮助检查是否进行了正确的方法覆写。</li></ul><h3 id="6-多态"><a href="#6-多态" class="headerlink" title="6.多态"></a>6.多态</h3><ul><li>多态: 某个方法的调用，是由实现调用方法的实例的实际类型决定的。</li><li>多态的功能:允许添加更多类型的子类实现相似的功能，在实现代码的高复用性的同时，也不需要修改基于父类的代码。</li><li>可以通过<code>super</code>关键字调用父类的方法。</li></ul><h3 id="7-final"><a href="#7-final" class="headerlink" title="7.final"></a>7.final</h3><ul><li>被<code>final</code>修饰的类不能被继承。</li><li>被<code>final</code>修饰的方法不能被覆写。</li><li>被<code>final</code>修饰的字段不能被重新赋值，但可在构造方法中初始化。</li><li>被<code>final</code>修饰的局部变量不能被重新赋值。</li></ul><h3 id="8-抽象类"><a href="#8-抽象类" class="headerlink" title="8.抽象类"></a>8.抽象类</h3><ul><li>抽象方法：只给出了方法的定义，但方法内没有实现如何语句，不能被执行，目的是让子类去实现它。</li><li>如果定义了抽象方法，相关类必须声明为抽象类，否则会导致编译失败。</li><li>抽象方法和抽象类都用关键字<code>abstract</code>修饰。</li><li>抽象类无法被实例化，并且子类必须实现父类定义的抽象方法，所以抽象类相当于定义了”规范”。</li><li>面向抽象编程：这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</li></ul><h3 id="9-接口"><a href="#9-接口" class="headerlink" title="9.接口"></a>9.接口</h3><ul><li>如果一个抽象类没有字段，并且所有方法都是抽象方法，那么这个类可改写为接口。</li><li>接口类用关键字<code>interface</code>声明，并且用关键字<code>implements</code>实现继承。</li><li>接口支持多继承，即一个类可以实现多个接口。</li><li>接口定义的方法默认是<code>public abstract</code>类型,所以在定义接口方法时可忽略不写。</li><li>一个接口可以继承自另一个接口，使用关键字<code>extends</code>实现继承。</li><li>在子类中增加default方法实现单独功能，可以不用修改父类方法，实现代码的灵活性。</li></ul><h3 id="10-接口vs抽象类"><a href="#10-接口vs抽象类" class="headerlink" title="10.接口vs抽象类"></a>10.接口vs抽象类</h3><table><thead><tr><th align="left">比较</th><th align="center">接口</th><th align="center">抽象类</th></tr></thead><tbody><tr><td align="left">继承</td><td align="center">多继承</td><td align="center">单继承</td></tr><tr><td align="left">字段</td><td align="center">无实例字段，但可有静态(static final)字段</td><td align="center">有实例字段</td></tr><tr><td align="left">抽象方法</td><td align="center">可定义抽象方法</td><td align="center">可定义抽象方法</td></tr><tr><td align="left">非抽象方法</td><td align="center">不能定义非抽象方法，但可有final方法</td><td align="center">可定义非抽象方法</td></tr></tbody></table><h3 id="11-静态字段-amp-静态方法"><a href="#11-静态字段-amp-静态方法" class="headerlink" title="11.静态字段&amp;静态方法"></a>11.静态字段&amp;静态方法</h3><ul><li>静态字段<ul><li>用<code>static</code>关键字修饰的字段为静态字段。</li><li>静态字段有共享空间，实例字段有单独的空间，换种话说，静态字段属于类，而实例字段属于实例对象。</li><li>普通通过<code>类名.字段</code>的方式访问静态字段。</li></ul></li><li>静态方法<ul><li>用<code>static</code>修饰的方法为静态方法。</li><li>静态方法内部不能访问实例字段，只能访问静态字段，因为静态方法只属于类而不属于实例。</li><li>接口可以有静态字段，并且静态字段必须用final修饰，编译器会自动加上这些修饰符。</li><li>普遍通过<code>类名.方法</code>的方式调用静态方法。</li></ul></li></ul><h3 id="12-包"><a href="#12-包" class="headerlink" title="12.包"></a>12.包</h3><ul><li>设置包(package)机制是为了解决同名类冲突的问题。</li><li>真实完整的类名为<code>包名.类名</code>。</li><li>Java文件和Class文件的存放目录层次与包名结构一致。</li><li>Java文件放在<code>src</code>目录下，class文件放在<code>bin</code>目录下。</li><li>包作用域:未被<code>public</code>,<code>private</code>,<code>protected</code>修饰的字段和方法为包的作用域。</li><li>在一个类中使用另一个包中的类<ul><li>通过写出完整类名。</li><li>通过<code>import</code>语句导入其他包中的类。</li><li>通过<code>import static </code>语句导入其他类的静态字段和静态方法。</li></ul></li><li>如果有两个类名称相同，那么只能<code>import</code>其中一个类，另一个写完整类名。</li><li>包名命名推荐使用倒置的域名来保证唯一性。</li></ul><h3 id="13-classpath-amp-jar"><a href="#13-classpath-amp-jar" class="headerlink" title="13.classpath&amp;jar"></a>13.classpath&amp;jar</h3><ul><li>classpath<ul><li><code>classpath</code>是一种环境变量，用来指示<code>jvm</code>搜索<code>.class</code>文件。</li><li>classpath的设定<ul><li>在系统环境变量中设置</li><li>在启动JVM时设置。<ul><li><code>java -cp /&lt;环境变量&gt; /&lt;文件&gt;</code></li></ul></li><li><code>rt.jar</code>是Java核心库的压缩包。</li></ul></li></ul></li><li>jar包<ul><li>jar包是一种zip格式的压缩文件。</li><li>/META-INF/MANIFEST.MF是jar包中特殊的文件，可以指定main-class及其它信息。</li></ul></li></ul><h3 id="14-模块"><a href="#14-模块" class="headerlink" title="14.模块"></a>14.模块</h3><ul><li><p>模块是为了管理依赖，模块以<code>.jmod</code>作为扩展名。</p></li><li><p><code>java.base</code>是”根模块”，所有模块直接或间接依赖<code>java.base</code>模块。</p></li><li><p><code>module-info.java</code>是模块的描述文件。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> hello.world &#123;</span><br><span class="line"><span class="keyword">requires</span> java.base; <span class="comment">// 可不写，任何模块都会自动引入java.base</span></span><br><span class="line"><span class="keyword">requires</span> java.xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以上，其中<code>module</code>是关键字，<code>hello.world</code>是模块的名称，<code>requires</code>表示引用其他模块。</p></li></ul>]]></content>
    
    
    <summary type="html">Java进阶学习之面向对象篇</summary>
    
    
    
    <category term="技术笔记" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="面向对象" scheme="http://example.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JDBC编程</title>
    <link href="http://example.com/2021/06/05/studynotes/java-jdbc/"/>
    <id>http://example.com/2021/06/05/studynotes/java-jdbc/</id>
    <published>2021-06-05T03:47:05.965Z</published>
    <updated>2021-01-01T08:55:28.570Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文是Java泛型篇，学习于<a href="https://www.liaoxuefeng.com/wiki/1252599548343744">廖雪峰的Java教程</a></p></blockquote><h2 id="JDBC编程"><a href="#JDBC编程" class="headerlink" title="JDBC编程"></a>JDBC编程</h2><h3 id="1-JDBC概述"><a href="#1-JDBC概述" class="headerlink" title="1.JDBC概述"></a>1.JDBC概述</h3><ul><li>概念：JDBＣ（Java　DataBase　Connectivity），是Java访问数据库的标准接口。</li><li>JDBC驱动：实现了JDBC接口的jar包称为JDBC驱动，只在运行期间被需要。</li></ul><h3 id="2-JDBC连接"><a href="#2-JDBC连接" class="headerlink" title="2.JDBC连接"></a>2.JDBC连接</h3><ul><li>Connection 表示JDBC连接。</li><li>获取一个Connection需要事先准备URL，用户名，和密码。</li><li>创建一个Connection实例可用DriverManager提供的静态方法</li></ul>]]></content>
    
    
    <summary type="html">Java进阶学习之JDBC编程</summary>
    
    
    
    <category term="技术笔记" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="JDBC" scheme="http://example.com/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型</title>
    <link href="http://example.com/2021/06/05/studynotes/java-genericity/"/>
    <id>http://example.com/2021/06/05/studynotes/java-genericity/</id>
    <published>2021-06-05T03:47:05.963Z</published>
    <updated>2020-10-31T01:53:44.286Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文是Java泛型篇，学习于<a href="https://www.liaoxuefeng.com/wiki/1252599548343744">廖雪峰的Java教程</a></p></blockquote><h2 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3>]]></content>
    
    
    <summary type="html">Java进阶学习之泛型</summary>
    
    
    
    <category term="技术笔记" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="Java泛型" scheme="http://example.com/tags/Java%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java异常</title>
    <link href="http://example.com/2021/06/05/studynotes/java-exception/"/>
    <id>http://example.com/2021/06/05/studynotes/java-exception/</id>
    <published>2021-06-05T03:47:05.956Z</published>
    <updated>2020-10-11T07:55:21.642Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文是Java异常篇，学习于<a href="https://www.liaoxuefeng.com/wiki/1252599548343744">廖雪峰的Java教程</a></p></blockquote><h2 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h2><h3 id="1-异常类型"><a href="#1-异常类型" class="headerlink" title="1.异常类型"></a>1.异常类型</h3><ul><li>异常体系的根为<code>Throwable</code>，它继承自<code>Object</code>。</li><li><code>Throwable</code>有两个体系<code>Error</code>和<code>Exception</code>。</li><li><code>Error</code>类<ul><li><code>OutOfMemoryError</code></li><li><code>NoClassDefFounderError</code></li><li><code>StackOverError</code></li><li>等等</li></ul></li><li><code>Exception</code>类<ul><li><code>RuntimeException</code><ul><li><code>IndexOutOfBoundsException</code></li><li><code>NullPointerException</code></li><li>等等</li></ul></li><li><code>非RuntimeException</code>(也叫<code>Checked Exception</code>异常)<ul><li><code>IOException</code></li><li><code>ReflectiveOperationException</code></li><li><code>NumberFormatException</code></li><li><code>FileNotFoundException</code></li><li><code>SocketException</code></li><li>等等</li></ul></li></ul></li><li><code>非RuntimeException</code>异常必须被捕获，<code>RuntimeExcept</code>异常不强制被捕获。</li><li>异常捕获使用<code>try&#123;&#125;···catch&#123;&#125;</code>语句。</li><li>其中<code>try</code>声明可能出现异常的方法，<code>catch</code>捕获异常Exception及其子类。</li><li><code>thorws</code>语句声明可能出现的异常，凡是用throws声明异常的方法，最终必须被捕获，如若不捕获，可在最高调用层<code>throws</code>异常，代价是发送异常的话程序会闪退。</li><li><code>printStackTrace()</code>方法可以打印异常栈。</li></ul><h3 id="2-多catch语句与finally"><a href="#2-多catch语句与finally" class="headerlink" title="2.多catch语句与finally"></a>2.多catch语句与finally</h3><ul><li>catch语句可以捕获多个异常，如果这些异常有继承关系，则需要分开捕获，例如如下代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意子类要放在父类异常前面，否则如果匹配到父类异常，子类异常将不会被捕获到。</li><li>如果无继承关系，则多个异常可以用<code>|</code>同时合并。</li><li><code>finally</code>语句可以保证无论是否发生异常都会被执行。</li><li>可以存在<code>try&#123;&#125;···finally&#123;&#125;</code>语句，前提是方法已经用<code>throws</code>语句声明异常。</li></ul><h3 id="3-抛出异常"><a href="#3-抛出异常" class="headerlink" title="3.抛出异常"></a>3.抛出异常</h3><ul><li>异常的传播：当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个<code>try&#123;&#125;···catch&#123;&#125;</code>语句被捕获为止。</li><li>如何抛出异常:创建某个异常实例，用<code>throws</code>语句抛出。</li><li>异常类型转换，如果在<code>try</code>语句中抛出异常，又在<code>catch</code>语句抛出新的异常，就会把异常类型转换。</li><li>获取原始异常的办法：<ul><li>把<code>try</code>捕获的原始异常的实例传入<code>catch</code>语句中抛出的新类型异常的参数中。</li><li>使用<code>getCause()</code>方法。</li></ul></li><li>如果在try或者catch语句中抛出异常，JVM会先执行finally语句，然后抛出异常。</li><li>异常屏蔽(Suppressed Exception)：如果在finally语句抛出异常，则catch语句的异常不会被抛出，由于JVM只能抛出一个异常。</li><li>打印输出被屏蔽的异常<code>SuppressedException</code>的方法：创建一个<code>Exception </code>实例，保存被屏蔽的异常的信息，判断存在SuppressedException后，用<code>addSuppressed()</code>方法把刚才创建的<code>Exception</code>实例添加进来，最后抛出异常。</li></ul><h3 id="4-自定义异常类型-amp-NullPointerException"><a href="#4-自定义异常类型-amp-NullPointerException" class="headerlink" title="4.自定义异常类型&amp;NullPointerException"></a>4.自定义异常类型&amp;NullPointerException</h3><ul><li><p>在一个大型项目中，通常的做法是自定义一个<code>BaseException</code>，并且建议继承自<code>RuntimeException</code>，最后由<code>BaseEduixception</code>派生出其他自定义异常类型。</p></li><li><p>对于<code>NullPointerException</code>异常，应当遵循早暴露早修复的原则。</p></li><li><p>为了防止出现<code>NullPointerException</code>异常，应有较好的编码习惯，比如用<code>&quot; &quot;</code>空字符串代替<code>null</code>。</p></li></ul><h3 id="5-断言"><a href="#5-断言" class="headerlink" title="5.断言"></a>5.断言</h3><ul><li>断言(Assertion)是一种调试程序的方式。</li><li>作用处:断言通常用在不在可恢复程序中，因为断言失败会导致程序结束提出。</li><li>断言的用法: 例如<code>assert  x&gt;=0</code>,如果x&lt;0，则断言失败，返回<code>AssertionError</code>；可以在断言的时候附带错误信息，例如<code>assert x&gt;=0 : &quot;x must &gt; 0&quot;</code>。</li><li>开启方式: 断言默认是关闭的，可以在命令行开启<code>java -enableassertions Main.java</code>。</li></ul><h3 id="6-JDK-Logging"><a href="#6-JDK-Logging" class="headerlink" title="6.JDK Logging"></a>6.JDK Logging</h3><ul><li><p><code>JDK Logging</code>可用于有针对性地调试代码。</p></li><li><p><code>JDK Logging</code>的使用：</p></li><li><p>位于<code>java.util.logging</code>包中。</p></li><li><p>有八种日志级别，默认级别为INFO，并且默认级别以下的日志不会被打印，但可设定默认级别。</p><ul><li>SEVERE<ul><li>WARNING</li><li>INFO</li><li>CONFIG</li><li>FINE</li><li>FINER</li><li>FINEST</li></ul></li></ul></li><li><p>示例代码</p></li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.learnjava;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Logger logger = Logger.getGlobal();</span><br><span class="line">        logger.info(<span class="string">&quot;start process...&quot;</span>);</span><br><span class="line">        logger.warning(<span class="string">&quot;memory is running out...&quot;</span>);</span><br><span class="line">        logger.fine(<span class="string">&quot;ignored.&quot;</span>);</span><br><span class="line">        logger.severe(<span class="string">&quot;process will be terminated...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>  ### 7.Commons Logging</code></pre><ul><li><code>Commons Logging</code>是一种第三方日志库，它由<code>Apache</code>创建，可作为日志接口来调用其他日志系统。</li><li>特点：可以挂载不同的日志系统，默认情况下先搜索<code>Log4j</code>，如果没找到，再使用<code>JDK Logging</code>。</li><li>使用<ul><li>首先可通过静态工厂方法<code>LogFactory.getLog()</code>方法(方法内的参数可以为<code>getclass()</code>或<code>当前类名.class</code>,Main)创建一个<code>Log</code>实例，再使用<code>Log</code>的实例方法打印日志。</li><li>如果在静态方法中引用<code>Log</code>示例，则需要定义静态<code>Log</code>实例，如果在实例方法中引用实例，则定义一个实例变量。</li><li>示例代码</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Log log = LogFactory.getLog(Main.class);</span><br><span class="line">        log.info(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;end.&quot;</span>);m</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>六种日志级别，其中<code>INFO</code>为默认级别。<ul><li>FATAL</li><li>ERROR</li><li>WARNING</li><li>INFO</li><li>DEBUG</li><li>TRACE</li></ul></li><li>注意：由于为第三方库，所以需要提前下载。</li></ul><h3 id="8-Log4j"><a href="#8-Log4j" class="headerlink" title="8.Log4j"></a>8.Log4j</h3><ul><li><code>Log4j</code>是一种日志系统，就跟<code>JDK Logging</code>一样。</li><li>Log4j的特点：可自动通过不同的Appender把同一条日志输出到不同的目的地。</li><li>使用：可通过修改配置文件，最后通过<code>Common Logging</code>来实现调用。</li></ul><h3 id="9-SLF4J和Logback"><a href="#9-SLF4J和Logback" class="headerlink" title="9.SLF4J和Logback"></a>9.SLF4J和Logback</h3><ul><li><code>SLF4J</code>相当于<code>Common Logging</code>。</li><li><code>Logback</code>相当于<code>Log4j</code>。</li><li>使用：<code>SLF4J</code>的接口实际上和<code>Commons Logging</code>几乎一模一样，不同之处就是<code>Log</code>变成了<code>Logger</code>，<code>LogFactory</code>变成了<code>LoggerFactory</code>。</li></ul>]]></content>
    
    
    <summary type="html">Java进阶学习之异常</summary>
    
    
    
    <category term="技术笔记" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java异常" scheme="http://example.com/tags/Java%E5%BC%82%E5%B8%B8/"/>
    
    <category term="Java日志" scheme="http://example.com/tags/Java%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Java核心类</title>
    <link href="http://example.com/2021/06/05/studynotes/java-core-classes/"/>
    <id>http://example.com/2021/06/05/studynotes/java-core-classes/</id>
    <published>2021-06-05T03:47:05.945Z</published>
    <updated>2020-10-05T03:11:02.875Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文是Java的面向对象篇，学习于<a href="https://www.liaoxuefeng.com/">廖雪峰的Java教程</a>.</p></blockquote><h2 id="Java核心类"><a href="#Java核心类" class="headerlink" title="Java核心类"></a>Java核心类</h2><h3 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h3><ul><li>String字符串内部是通过一个<code>char[]</code>表示的。</li><li>String字符串不可变性的实现：通过内部的<code>private final char[]</code>实现。</li><li>字符串的比较<ul><li>用<code>equals()</code>方法来比较，而不用<code>==</code>。</li><li>Java编译器在编译期间，会把拥有相同字符串的对象视为同一个对象并且放入常量池，所以用<code>==</code>比较字符串得出的结果会有巧合性。</li><li>忽略大小写比较字符串用<code>equalsIgnoreCase()</code>方法。</li></ul></li><li>判断是否包含子串用<code>contains()</code>方法，参数为<code>CharSequence</code>类，为String的子类。</li><li>搜索字串<ul><li><code>indexOf()</code>方法返回字串第一次出现在前半部分的索引。</li><li><code>lastIndexOf()</code>方法返回子串第一次出现在后半部分的索引。</li></ul></li><li>判断是否以子串开头或结尾<ul><li><code>startsWith()</code>判断是否以子串开头。</li><li><code>endsWith()</code>判断是否以字串结尾。</li></ul></li><li>提取字串<ul><li><code>substring(2)</code>从索引为2处开始提取字串。</li><li><code>substring(2,4)</code>从索引为2处开始提取，到索引为4处结束，但不包括索引为4的值。</li></ul></li><li>去除首尾空白字符<ul><li><code>trim()</code>方法，空白字符包括<code>\t</code>、<code>\r</code>、<code>\n</code>。</li><li><code>strip()</code>方法，与<code>trim</code>方法的区别就是可以去除中文空格字符<code>\u3000</code>。</li></ul></li><li>判断是否为空<ul><li><code>isBlank()</code>方法可以判断是否包含空白字符。</li><li><code>isEmpty</code>方法可以判断是否字符串的长度是否为0，<em>空白字符也可作为一个字符串长度。</em></li></ul></li><li>替换子串用<code>replace(s1,s2)</code>方法，其中第一个参数s1表示被替换的子串，第二个参数s2为替换的子串。</li><li><code>spilt()</code>方法可以分割字符串。</li><li>格式化字符串<ul><li><code>formatted()</code></li><li><code>format()</code>静态方法</li><li>示例代码</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;Hi %s, your score is %d!&quot;</span>;</span><br><span class="line">        System.out.println(s.formatted(<span class="string">&quot;Alice&quot;</span>, <span class="number">80</span>));</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Hi %s, your score is %.2f!&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">59.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>类型转换<ul><li>基本数据类型或引用类型转String类型。<ul><li>使用<code>String.valueOf()</code>静态方法。</li><li>使用<code>toString()</code>静态方法。</li></ul></li><li>String类型转其他类型：<ul><li>转int:<code>Integer.parseInt()</code>或<code>Integer.valueOf()</code>方法。</li><li>转bolean:<code>Bolean.parseBolean()</code>或<code>Boolean.valueOf()</code>方法。</li><li>···</li></ul></li></ul></li><li>char[ ]和String的相互转换<ul><li>String转char[ ]：<code>char[] arr = s.toCharArray()</code>即<code>toCharArray()</code>方法。</li><li>char[ ]转String：<code>String s =new String (arr)</code></li></ul></li></ul><h3 id="2-StringBuilder"><a href="#2-StringBuilder" class="headerlink" title="2.StringBuilder"></a>2.StringBuilder</h3><ul><li>在循环中使用 <code>+</code> 拼接字符串会生成许多临时对象，这些会造成内存浪费，同时会影响GC效率，<code>StringBuilder</code>可以有效解决这个问题。</li><li><code>StringBuilder</code>是一种可变类，可以预分配缓冲区。</li><li><code>StringBuilder</code>使用<code>append()</code>方法拼接子串。</li><li><code>StringBuilder</code>使用<code>delete()</code>方法删除子串。</li><li><code>StringBuffer</code>是<code>StringBuilder</code>的线程安全版本，实现了相同的接口。</li><li>可以通过同步来保证线程操作，但同步会带来执行速度的下降。</li></ul><h3 id="3-StringJoiner"><a href="#3-StringJoiner" class="headerlink" title="3.StringJoiner"></a>3.StringJoiner</h3><ul><li><code>Stringjoiner</code>类最常用于用分隔符拼接数组，使用<code>add()</code>方法拼接。</li><li>用法：<code>var sj = new StringJoiner(&quot;s1&quot;)</code>，其中参数s1为分隔符。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> sj = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">    sj.add(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果要指定开头和结尾，<code>var sj = new StringJoiner(&quot;s1&quot;,&quot;s2&quot;,&quot;s3&quot;)</code>，其中参数s1为分隔符，s2为开头，s3为结尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> sj = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">    sj.add(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>String.join()</code>为String类的静态方法，内部使用了<code>StringJonier</code>类的方法来拼接子串。</p></li><li><p><code>String.join()</code>方法的使用:<code>s.join(&quot;s&quot;,arr)</code>，其中s为要拼接的子串，arr为字符串数组。</p></li></ul><h3 id="4-包装类型"><a href="#4-包装类型" class="headerlink" title="4.包装类型"></a>4.包装类型</h3><ul><li>基本数据类型变为引用类型，其实是使引用类型包含一个基本类型的字段。</li><li>包装类：与某种基本类型对应的引用类型称为包装类(Wrapper Class)。</li><li>需要注意两种引用类型<code>Integer</code>和<code>Character</code>，其他基本与基本类型的名称一致。</li><li>推荐使用包装类型的静态方法<code>valueOf()</code>创建实例，而不通过构造方法创建，因为会有编译警告。</li><li>自动装箱(Auto Boxing):将基本类型自动转换为引用类型。</li><li>自动拆箱(Auto Unboxing):将引用类型自动转换为基本类型。</li><li>自动装箱和自动拆箱只发生在编译阶段，优点是少写代码，缺点是影响执行效率。</li><li>静态工厂方法：能创建新实例的静态方法，它有缓存优化机制。</li><li>如果静态工厂方法<code>valueOf()</code>中的参数很小，会返回相同的实例，由于缓存优化。</li><li>包装类型转化为基本类型<ul><li>使用形如<code>intvalue()</code>的方法、</li><li>使用形如<code>parseInt()</code>的方法。</li></ul></li><li>包装类型的静态变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Boolean t = Boolean.TRUE;</span><br><span class="line">Boolean f = Boolean.FALSE;</span><br><span class="line"><span class="comment">// int可表示的最大/最小值:</span></span><br><span class="line"><span class="keyword">int</span> max = Integer.MAX_VALUE; <span class="comment">// 2147483647</span></span><br><span class="line"><span class="keyword">int</span> min = Integer.MIN_VALUE; <span class="comment">// -2147483648</span></span><br><span class="line"><span class="comment">// long类型占用的bit和byte数量:</span></span><br><span class="line"><span class="keyword">int</span> sizeOfLong = Long.SIZE; <span class="comment">// 64 (bits)</span></span><br><span class="line"><span class="keyword">int</span> bytesOfLong = Long.BYTES; <span class="comment">// 8 (bytes)</span></span><br></pre></td></tr></table></figure><h3 id="5-JavaBean"><a href="#5-JavaBean" class="headerlink" title="5.JavaBean"></a>5.JavaBean</h3><ul><li><code>JavaBean</code>主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。</li><li>一组对应的读写方法称为属性。</li><li>只有读方法的称为只读属性，只有写方法的称为只写属性。</li></ul><h3 id="6-Enum"><a href="#6-Enum" class="headerlink" title="6.Enum"></a>6.Enum</h3><ul><li>用<code>enum</code>关键字定义的类称为枚举类，它被编译器编译为<code>final class Xxx extends Enum &#123; … &#125;</code>；</li><li>注意：<ul><li>枚举常量带有类型信息。</li><li>不能用非枚举类型的值给枚举常量赋值。</li><li>不同类型的枚举不能相互比较。</li></ul></li><li>枚举的比较<ul><li><code>== </code>运算符，枚举类是一种特殊的class，可以用<code>==</code>运算符比较，因为每一个枚举常量在JVM内都是一个唯一的实例。</li><li><code>equals()</code>方法，可编译通过，但更推荐用<code>==</code>运算符，可以写更少的代码。</li></ul></li><li>枚举类的特点<ul><li>继承自<code>java.lang.Enum</code>，且枚举类无法被继承，因为枚举类被<code>fintal</code>关键字修饰。</li><li>只能定义enum的实例，不能用new操作符创建实例。</li><li>可以用于<code>switch</code>语句。</li><li>每一个枚举常量在内部都是一个唯一的实例。</li></ul></li><li><code>name()</code>返回枚举常量名。</li><li><code>ordinal()</code>返回枚举常量按顺序定义的序号，以0开始计数。</li><li>enum的构造方法应该声明为<code>private类型</code>。</li><li>给枚举常量添加字段，字段强烈建议声明为<code>final</code>类型，并且在<code>pirvate</code>构造方法中初始化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    MON(<span class="number">1</span>, <span class="string">&quot;星期一&quot;</span>), TUE(<span class="number">2</span>, <span class="string">&quot;星期二&quot;</span>), WED(<span class="number">3</span>, <span class="string">&quot;星期三&quot;</span>), THU(<span class="number">4</span>, <span class="string">&quot;星期四&quot;</span>), FRI(<span class="number">5</span>, <span class="string">&quot;星期五&quot;</span>), SAT(<span class="number">6</span>, <span class="string">&quot;星期六&quot;</span>), SUN(<span class="number">0</span>, <span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> dayValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String chinese;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Weekday</span><span class="params">(<span class="keyword">int</span> dayValue, String chinese)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayValue = dayValue;</span><br><span class="line">        <span class="keyword">this</span>.chinese = chinese;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="7-Record"><a href="#7-Record" class="headerlink" title="7.Record"></a>7.Record</h3><ul><li>不变类的两个特点<ul><li><code>class</code>用<code>final</code>关键字修饰。</li><li>字段也用<code>final</code>关键字修饰。</li></ul></li><li>用关键字<code>record</code>声明的类称为记录类。</li><li>跟枚举类一样，它不直接继承自<code>Record</code>类，而由编译器实现继承，并且被编译器编译为<code>public final class Xxx extends Record &#123;···&#125;</code></li><li>记录类的声明方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Xxx</span><span class="params">(type x,type y)</span></span>;</span><br></pre></td></tr></table></figure><p>它被编译器编译后的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">extends</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> type x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> type y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(type x, type y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> type <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> type <span class="title">y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Point[x=%s, y=%s]&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以在记录类的构造方法中编写逻辑检查语法。</li><li>可以在记录类中用<code>of()</code>静态方法创建实例。</li></ul><h3 id="8-BigInteger"><a href="#8-BigInteger" class="headerlink" title="8.BigInteger"></a>8.BigInteger</h3><ul><li>由CPU原生提供的long整型最大位数是64位，可直接通过CPU进行计算。</li><li><code>java.math.BigInteger</code>表示任意大小的整数，内部以<code>int[ ]</code>数组表示。</li><li>使用BigInteger做运算的时候，要用实例方法。</li><li><code>BigInteger</code>转<code>long</code>时，如果超出<code>long</code>范围，用<code>longValneExact()</code>方法会报出<code>ArithmeticException</code>异常，用<code>longValne()</code>方法不会报出异常，但会丢失高位信息，即得出的结果不准确。</li><li><code>BigInteger</code>类型也可转基本类型，因为<code>BigInteger</code>也继承自<code>Number</code>类。</li></ul><h3 id="9-BigDecimal"><a href="#9-BigDecimal" class="headerlink" title="9.BigDecimal"></a>9.BigDecimal</h3><ul><li><code>BigDecimal</code>表示任意精度的浮点数。</li><li>使用<code>scale()</code>方法可以返回小数位数，如果返回负数，表示这是整数，并且末尾有整数0。</li><li>使用<code>stripTrailingZeros()</code>方法可以返回一个相等的，去除了末尾0的<code>BigDecimal</code>数。</li><li>使用<code>setScale()</code>方法可以设置精度，如果设置精度小与原始精度，就要考虑四舍五入或者直接截断。</li><li><code>RoundingMode.HALF_UP</code>常量表示四舍五入。</li><li><code>RoundingMode.Down</code>常量表示直接截断。</li><li>比较两个<code>BigDecimal</code>使用<code>compareTo()</code>方法。</li><li><code>BigDecimal</code>实际上是由<code>BigInteger</code>和<code>sacle</code>表示的。</li></ul><h3 id="10-Math"><a href="#10-Math" class="headerlink" title="10.Math"></a>10.Math</h3><ul><li>数学公式<ul><li><code>Math.abs()</code>计算绝对值。</li><li><code>Math.max()</code>计算最大值，<code>min()</code>计算最小值</li><li><code>Math.pow(x,y)</code>计算$x^y$次方。</li><li><code>Math.sqrt(x)</code>计算$\sqrt{x}$。</li><li><code>Math.exp(x)</code>计算$e^x$。</li><li><code>Math.log(x)</code>计算$\log_ex$。</li><li><code>Math.log10(x)</code>计算$\ln x$。</li><li><code>Math.sin(x)</code>计算$\sin x$。</li><li><code>Math.cos(x)</code>计算$\cos x$。</li><li><code>Math.tan(x)</code>计算$\tan x$。</li><li><code>Math.asin(x)</code>计算$asin x$。</li><li><code>Math.acos(x)</code>计算$acos x$。</li><li><code>Math.PI</code>数学常量，表示$\Pi$</li><li><code>Math.E</code>数学常量，表示e。</li></ul></li><li><code>Math.random()</code>返回<code>[0,1</code>之间的随机数。</li></ul><h3 id="11-Random"><a href="#11-Random" class="headerlink" title="11.Random"></a>11.Random</h3><ul><li><code>Random</code>类用来创建伪随机数，伪随机数是指给定一个种子，会产生相同的随机数序列。</li><li><code>Math.random()</code>实际上内部调用了<code>Random</code>类。</li><li><code>SecureRandom</code>类用来产生安全的随机数。</li></ul>]]></content>
    
    
    <summary type="html">Java进阶学习之核心类</summary>
    
    
    
    <category term="技术笔记" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="核心类" scheme="http://example.com/tags/%E6%A0%B8%E5%BF%83%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="http://example.com/2021/06/05/studynotes/java-annotation/"/>
    <id>http://example.com/2021/06/05/studynotes/java-annotation/</id>
    <published>2021-06-05T03:47:05.941Z</published>
    <updated>2020-10-23T03:54:08.098Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文是Java注解篇，学习于<a href="https://www.liaoxuefeng.com/wiki/1252599548343744">廖雪峰的Java教程</a></p></blockquote><h2 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h2><h3 id="1-注解"><a href="#1-注解" class="headerlink" title="1.注解"></a>1.注解</h3><ul><li>注解(Annotation)是一种<code>特殊的注释</code>,作用于Java源码的类，方法，字段，参数前。</li><li>注解与代码的关系：从<strong>JVM</strong>的角度看，注解本身对代码的逻辑没有任何影响。</li><li>注解分类<ul><li>作用于编译器，但不会进入<code>.class</code>件，编译后不复存在,例如<ul><li><code>@override</code>告诉编译器检查是否进行了正确的代码覆写</li><li><code>@suppressWarning</code>告诉编译器忽略当前产生的编译警告。</li></ul></li><li>作用于<code>class</code>文件，但加载后不会存在于内存中。</li><li>作用于<code>JVM</code>，在程序运行时能够读取，例如<ul><li>配置了<code>@PostConstruct</code>参数的方法在调用构造方法时被自动调用。</li></ul></li></ul></li><li>注解的配置参数必须是常量，注解的配置参数可以有默认值。</li></ul><h3 id="2-定义注解"><a href="#2-定义注解" class="headerlink" title="2.定义注解"></a>2.定义注解</h3><ul><li>使用<code>@interface</code>语法来定义注解，并且可用<code>default</code>定义一个默认值，格式如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>元注解(meta annotation)可以修饰其他注解。<ul><li><code>@Target</code>声明注解可以作用于源码的哪个部分。<ul><li>类或接口：<code>ElementType.TYPE</code>；</li><li>字段：<code>ElementType.FIELD</code>；</li><li>方法：<code>ElementType.METHOD</code>；</li><li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li><li>方法参数：<code>ElementType.PARAMETER</code>。</li><li>示例代码</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">    ElementType.METHOD,</span></span><br><span class="line"><span class="meta">    ElementType.FIELD</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>@Retention</code>定于注解的生命周期</p><ul><li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li><li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li><li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li></ul></li><li><p><code>@Repeatable</code>定义注解是否可重复。</p></li><li><p><code>@Inherited</code>定义注解是否可继承，<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的注解有效。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repeatable(Reports.class)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> &quot;info&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-处理注解"><a href="#3-处理注解" class="headerlink" title="3.处理注解"></a>3.处理注解</h3><ul><li><p>注解本身也是一种class，它继承自<code>java.lang.annotation.Annotation</code>。</p></li><li><p>利用反射API读取注解</p><ul><li>判断某个注解是否存在<ul><li><code>Class.isAnnotationPresent(Class)</code>判断类中是否存在某个注解。</li><li><code>Field.isAnnotationPresent(Class)</code>判断字段中是否存在某个注解。</li><li><code>Method.isAnnotationPresent(Class)</code>判断方法中是否存在某个注解。</li><li><code>Constructor.isAnnotationPresent(Class)</code>判断构造方法中是否存在某个注解。</li></ul></li><li>获取注解<ul><li><code>Class.getAnnotation(Class)</code>获取类的某个注解</li><li><code>Method.getAnnotation(Class)</code>获取方法的某个注解</li><li><code>Field.getAnnotation(Class)</code>获取字段的某个注解</li><li><code>Constructor.getAnnotation(Class)    </code>获取构造器的某个注解</li><li>因为方法参数本身可以有多个注解，所以方法参数可以用二维数组表示。</li></ul></li></ul></li><li><p>使用注解</p><ul><li>因为注解本身并不破坏代码逻辑，所以我们需要额外编写代码来使用注解。</li><li>可以配合<code>check()</code>方法来使用注解。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">Java进阶学习之注解</summary>
    
    
    
    <category term="技术笔记" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="Java注解" scheme="http://example.com/tags/Java%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java入门</title>
    <link href="http://example.com/2021/06/05/studynotes/java-%20introduction%20/"/>
    <id>http://example.com/2021/06/05/studynotes/java-%20introduction%20/</id>
    <published>2021-06-05T03:47:05.929Z</published>
    <updated>2020-10-05T03:59:16.967Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本文是Java的入门学习篇，学习于<a href="https://www.liaoxuefeng.com/wiki/1252599548343744">廖雪峰的Java教程</a>。</p></blockquote><h2 id="1-Java介绍"><a href="#1-Java介绍" class="headerlink" title="1.Java介绍"></a>1.Java介绍</h2><p>最早由James golis开发，起初叫oak.</p><p>JDK:Java Development Kit</p><ul><li>Java开发工具箱。</li><li>包含了编译器，调试器，虚拟机等一系列开发工具。</li></ul><p>JRE：Java Runtime Rnvironment</p><ul><li>Java虚拟机。</li><li>运行字节码文件，JRE是JDK的一部分。</li></ul><p> JSR：Java Specification request</p><ul><li>Java规范要求。</li><li>规范Java平台新增加的功能。</li></ul><p>JCP：Java Community process</p><ul><li>Java社区流程。</li><li>审核JSR。</li></ul><h2 id="2-Java工具"><a href="#2-Java工具" class="headerlink" title="2.Java工具"></a>2.Java工具</h2><p> java</p><ul><li>其实就是虚拟机，执行字节码文件。</li></ul><p>javac</p><ul><li>全称Java Compiler,编译源文件为字节码文件。</li></ul><p>jar</p><ul><li>把字节码文件打包为jar压缩文件。</li></ul><p>javadoc</p><ul><li>生成注释文档。</li></ul><p>jdb</p><ul><li>全称Java Debugger,Java 调试器，用于开发时进行代码调试。</li></ul><h2 id="3-Java基础"><a href="#3-Java基础" class="headerlink" title="3.Java基础"></a>3.Java基础</h2><p>Java类名书写规范</p><ul><li>类名必须以英文字母开头，后接字母.数字或下划线。</li><li>类名首字母习惯大写，此后后面的每个单词首字母都大写。</li></ul><p>Java程序的入口方法</p><ul><li>静态的main方法，Java程序总是从main方法开始执行的。</li></ul><p>方法名书写规范</p><ul><li>方法名必须以英文字母开头，后接字母，数字或下划线。</li><li>方法名首字母习惯小写，此后后面的每个单词首字母大写。</li></ul><p>Java的文档注释</p><ul><li>标识在方法和类名的定义处，用于自动创建文档。</li></ul><p>Java变量</p><ul><li>分为基本类型变量和隐形类型变量。</li><li>基本类型变量如未初始化，则默认值为0.</li><li>引用类型变量如未初始化，则默认值为null.</li></ul><p>Java基本数据类型</p><ul><li><p>int</p><ul><li>占4个字节。</li><li>范围：-2147483648-2147483647.</li></ul></li><li><p>short</p><ul><li>占2个字节.</li><li>范围：-32768-32767.</li></ul></li><li><p>byte</p><ul><li>占1个字节.</li><li>范围：-128-127.</li></ul></li><li><p>long</p><ul><li>占8个字节.</li><li>范围：-9223372036854775808 -9223372036854775807</li></ul></li><li><p>double</p><ul><li>占8个字节.</li></ul></li><li><p>float</p><ul><li>占4个字节.</li></ul></li><li><p>char</p><ul><li>占2个字节.</li></ul></li></ul><p>java运算</p><ul><li><p>两个整数相除，结果忽略小数部分。</p></li><li><p>按位运算是对4字节的8位二进制数进行左移或者右移。</p></li><li><p>如果对负数进行按位右移，由于符号位为1不动，所以结果仍然是负数。</p></li><li><p>无符号位移运算用&gt;&gt;&gt;或&lt;&lt;&lt;,表示符号位也会跟着变动。</p></li><li><p>与运算</p><ul><li>两个数同时为1，结果才为1。</li><li>与运算的常见用途：两个IP地址进行与运算，判断一个IP是否在给定的网段内。</li></ul></li><li><p>或运算</p><ul><li>其中一个数为1，结果才为1.</li></ul></li><li><p>非运算</p><ul><li>非0即1，非1即0.</li></ul></li><li><p>异或运算</p><ul><li>两个数不同，结果为1，否则为0.</li></ul></li><li><p>浮点数四舍五入转换为整数</p><ul><li>浮点数+0.5再进行转换。</li></ul></li></ul><p>Java字符的表示</p><ul><li>一是用单引号括起来的字符表示。</li><li>二是用单引号括起来的转义字符表示。</li><li>其中转义字符的表示：\u+四位十六进制数。</li></ul><p> Java字符串连接</p><ul><li>字符串变量可用+号连接其他字符串或者其他数据类型。</li><li>如果用+号连接其他数据类型，则其他数据类型的会先自动转变为字符串。</li><li>Java表示多行字符串可用符号 ”‘  “’ 。</li><li>Java的不可变性指的是字符串内容不会变，只是指针指向了另一个字符串内容。</li></ul><p>null值</p><ul><li>表示变量未指向任何对象。</li></ul><p>Java数组</p><ul><li>是同一数据类型的集合。</li><li>初始化时，如果是整数，默认值为0，如果是浮点数默认值为0.0，如果是布尔，默认值为false。</li></ul><p>判断两个浮点数是否相同</p><ul><li>两个浮点数之差的绝对值是否小于0.00001.</li></ul><p>Java特殊的三个数值</p><ul><li>NaN Not a Number.</li><li>Infinity 无穷大。</li><li>-Infinity 负无穷大。</li></ul><p>基本类型变量和引用型变量的值</p><ul><li><p>基本类型变量的值是数值。</p></li><li><p>引用型变量的值为引用，相当于指针。</p></li><li><p>比较方法：</p><ul><li>两个基本类型变量的比较用==。</li><li>两个引用类型变量的比较用equals方法。</li></ul></li></ul><p>Java类型转换</p><ul><li>低等级类型向高等级类型转换是自动转换。</li><li>高等级类型向低等级类型转换是强制转换。</li></ul><p>java数组大小与引用</p><ul><li>数组大小不会变化，所谓变化只是指向了新的数组。</li><li>Java数组变量指向一个新数组后，原数组不会消失，只是无法通过引用访问。</li></ul><p>for循环与for-each循环</p><ul><li>for循环执行流程：先初始化计时器，再判断循环条件，最后再更新计时器。</li><li>for-each循环适用于数组.</li></ul><p>conuite与break</p><ul><li>continue结束本次循环。</li><li>break结束当前所在的一层循环。</li></ul><p>数组相关</p><ul><li><p>打印数组变量时，输出的是数组首元素索引。</p></li><li><p>数组的排序</p><ul><li>常见排序方法</li><li>Array.sort()方法，默认从小到大排序。</li></ul></li><li><p>二维数组的长度</p><ul><li>二维数组的元素是数组，所以二维数组的长度为数组元素个数。</li><li>二位数组元素的长度不要求相同。</li></ul></li><li><p>数组元素的两种打印输出方法</p><ul><li>for循环</li><li>Array.toString() 方法格式化输出</li><li>Array.deepToString()方法格式化输出，适用于多维数组。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">Java进阶学习之入门篇~</summary>
    
    
    
    <category term="技术笔记" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="JDK" scheme="http://example.com/tags/JDK/"/>
    
    <category term="Java基础" scheme="http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HTML</title>
    <link href="http://example.com/2021/06/05/studynotes/HTML/"/>
    <id>http://example.com/2021/06/05/studynotes/HTML/</id>
    <published>2021-06-05T03:47:05.923Z</published>
    <updated>2020-08-24T02:00:40.003Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p>1.一种描述网页的文本标记语言.<br>2.通过HTML标签来表述网页.</p><h2 id="一-HTML元素"><a href="#一-HTML元素" class="headerlink" title="一.HTML元素"></a>一.HTML元素</h2><p>1.HTML元素是开始标签到束标签之间的文本内容.<br>2.空元素在开始标签中结束。（在开始标签后尖括号加斜杠/).</p><h2 id="二-HTML文档"><a href="#二-HTML文档" class="headerlink" title="二.HTML文档"></a>二.HTML文档</h2><p>1.HTML文档=网页=HTML标签+纯文本.<br>2.以. htm 或 .html 为后缀名.<br>3.<DOCTYPE>声明HTML版本.</p><h2 id="三-基本HTML标签以及对应的属性"><a href="#三-基本HTML标签以及对应的属性" class="headerlink" title="三.基本HTML标签以及对应的属性"></a>三.基本HTML标签以及对应的属性</h2><p>1.用来描述网页.<br>2.以尖括号成对出现.<br>3.属性值由双引号括起来，如果属性值本身有双引号，就用单引号.</p><h3 id="1-lt-html-gt"><a href="#1-lt-html-gt" class="headerlink" title="1.&lt; html &gt;"></a>1.&lt; html &gt;</h3><p>描述网页内容.</p><h3 id="2-lt-body-gt"><a href="#2-lt-body-gt" class="headerlink" title="2.&lt; body &gt;"></a>2.&lt; body &gt;</h3><p>描述网页内容的主题.</p><ul><li><p>background</p><ul><li>设置背景图像.</li></ul></li><li><p>bgcolo</p><ul><li>设置背景颜色.</li></ul></li></ul><h3 id="3-lt-h1-h6-gt"><a href="#3-lt-h1-h6-gt" class="headerlink" title="3.&lt; h1-h6 &gt;"></a>3.&lt; h1-h6 &gt;</h3><p>将文本设置为标题文本.</p><h3 id="4-lt-p-gt"><a href="#4-lt-p-gt" class="headerlink" title="4.&lt; p &gt;"></a>4.&lt; p &gt;</h3><p>1.将为本设置为段落.<br>2.自动添加前后行.<br>3.浏览器会省去多余的空格和换行，统一以一个空格表示.</p><ul><li><p>align</p><ul><li>设置对齐方式.</li></ul></li><li><p>bgcolor</p><ul><li>设置背景颜色.</li></ul></li></ul><h3 id="6-lt-br-gt"><a href="#6-lt-br-gt" class="headerlink" title="6.&lt; br / &gt;"></a>6.&lt; br / &gt;</h3><p>插入一个空行来进行换行。</p><h3 id="8-lt-hr-gt"><a href="#8-lt-hr-gt" class="headerlink" title="8.&lt; hr / &gt;"></a>8.&lt; hr / &gt;</h3><p>创建水平线.</p><h3 id="9-lt-–-gt"><a href="#9-lt-–-gt" class="headerlink" title="9.&lt; !– &gt;"></a>9.&lt; !– &gt;</h3><p>1.注释作用，不会在浏览器中显示.<br>2.给计算机源代码注释.</p><h3 id="lt-link-gt"><a href="#lt-link-gt" class="headerlink" title="&lt; link &gt;"></a>&lt; link &gt;</h3><p>1.定义文档与被链接资源的关系.<br>2.最常见的用途事链接样式表.</p><ul><li><p>href</p><ul><li>定义被链接资源的位置.</li></ul></li><li><p>hreflang</p><ul><li>定义被链接文档的语言.</li></ul></li><li><p>rel</p><ul><li>定义被链接文档与当前文档的关系.</li></ul></li><li><p>type</p><ul><li>定义被链接文档的MIME类型.</li></ul></li><li><p>sizes</p><ul><li>定义被链接资源的尺寸，仅适用于rel=”icon”.</li></ul></li></ul><h3 id="10-style属性"><a href="#10-style属性" class="headerlink" title="10.style属性"></a>10.style属性</h3><p>1.一个HTML标签的多个属性以空格分隔.<br>2.style是一种通用属性，用于定义文本样式.<br>style=“ background-color：red”背景颜色.<br>3.多个属性值要以分号分隔开来.<br>style=”font-family:arial;color:red;font-size:20px;</p><ul><li><p>background-color</p><ul><li>设置背景颜色.</li></ul></li><li><p>font-family</p><ul><li>设置字体.</li></ul></li><li><p>font-size</p><ul><li>设置字体大小.</li></ul></li><li><p>text-align</p><ul><li>设置文本对齐方式.</li></ul></li></ul><h2 id="四-HTML图像"><a href="#四-HTML图像" class="headerlink" title="四.HTML图像"></a>四.HTML图像</h2><h3 id="7-lt-img-gt"><a href="#7-lt-img-gt" class="headerlink" title="7.&lt; img &gt;"></a>7.&lt; img &gt;</h3><p>1.描述图片.<br>2.设置图片链接的方式，将<img>标签作为<a>标签的元素.</p><ul><li><p>height</p><ul><li>设置图片宽度.</li></ul></li><li><p>width</p><ul><li>设置图片宽度.</li></ul></li><li><p>src</p><ul><li>设置图片地址.</li></ul></li><li><p>align</p><ul><li>设置图片对齐方式.</li></ul></li><li><p>alt</p><ul><li>为图像定义说明，当图片不能正常显示时.</li></ul></li></ul><h2 id="五-HTML链接"><a href="#五-HTML链接" class="headerlink" title="五.HTML链接"></a>五.HTML链接</h2><h3 id="5-lt-a-gt"><a href="#5-lt-a-gt" class="headerlink" title="5.&lt; a  &gt;"></a>5.&lt; a  &gt;</h3><p>1.描述链接地址。<br>2.单击文本元素可跳转。</p><ul><li><p>href</p><ul><li>设置目标的链接地址</li></ul></li><li><p>target</p><ul><li>设置链接目标的打开方式</li></ul></li><li><p>name</p><ul><li>定义锚的名称，主要用于书签，可以创建<a href=#锚>的链接跳转到书签。</li></ul></li></ul><h2 id="六-HTML标签之文本格式化"><a href="#六-HTML标签之文本格式化" class="headerlink" title="六.HTML标签之文本格式化"></a>六.HTML标签之文本格式化</h2><h3 id="lt-b-gt"><a href="#lt-b-gt" class="headerlink" title="&lt;\b&gt;"></a>&lt;\b&gt;</h3><ul><li>定义粗体文本</li></ul><h3 id="lt-big-gt"><a href="#lt-big-gt" class="headerlink" title="&lt; big &gt;"></a>&lt; big &gt;</h3><ul><li>定义大号字</li></ul><h3 id="lt-small-gt"><a href="#lt-small-gt" class="headerlink" title="&lt; small &gt;"></a>&lt; small &gt;</h3><ul><li>定义小号字</li></ul><h3 id="lt-i-gt"><a href="#lt-i-gt" class="headerlink" title="&lt; i &gt;"></a>&lt; i &gt;</h3><ul><li>定义斜体字</li></ul><h3 id="lt-em-gt"><a href="#lt-em-gt" class="headerlink" title="&lt; em &gt;"></a>&lt; em &gt;</h3><ul><li>定义强调字</li></ul><h3 id="lt-strong-gt"><a href="#lt-strong-gt" class="headerlink" title="&lt; strong &gt;"></a>&lt; strong &gt;</h3><ul><li>定义加重文字</li></ul><h3 id="lt-sub-gt"><a href="#lt-sub-gt" class="headerlink" title="&lt; sub &gt;"></a>&lt; sub &gt;</h3><ul><li>定义下标字</li></ul><h3 id="lt-sup-gt"><a href="#lt-sup-gt" class="headerlink" title="&lt; sup &gt;"></a>&lt; sup &gt;</h3><ul><li>定义上标字</li></ul><h3 id="lt-ins-gt"><a href="#lt-ins-gt" class="headerlink" title="&lt; ins &gt;"></a>&lt; ins &gt;</h3><ul><li>定义插入字</li></ul><h3 id="lt-del-gt"><a href="#lt-del-gt" class="headerlink" title="&lt; del &gt;"></a>&lt; del &gt;</h3><ul><li>定义删除字</li></ul><h3 id="lt-code-gt"><a href="#lt-code-gt" class="headerlink" title="&lt; code &gt;"></a>&lt; code &gt;</h3><ul><li>定义计算机代码</li></ul><h3 id="lt-bkd-gt"><a href="#lt-bkd-gt" class="headerlink" title="&lt; bkd &gt;"></a>&lt; bkd &gt;</h3><ul><li>定义键盘输入文字</li></ul><h3 id="lt-samp-gt"><a href="#lt-samp-gt" class="headerlink" title="&lt; samp &gt;"></a>&lt; samp &gt;</h3><ul><li>定义计算机代码样本</li></ul><h3 id="lt-var-gt"><a href="#lt-var-gt" class="headerlink" title="&lt; var&gt;"></a>&lt; var&gt;</h3><ul><li>定义计算机变量</li></ul><h3 id="lt-tt-gt"><a href="#lt-tt-gt" class="headerlink" title="&lt;  tt&gt;"></a>&lt;  tt&gt;</h3><ul><li>打字机代码</li></ul><h3 id="lt-pre-gt"><a href="#lt-pre-gt" class="headerlink" title="&lt; pre &gt;"></a>&lt; pre &gt;</h3><p>保留空格和拆行。</p><ul><li>定义预格式文本</li></ul><h3 id="lt-abbr-gt"><a href="#lt-abbr-gt" class="headerlink" title="&lt; abbr &gt;"></a>&lt; abbr &gt;</h3><ul><li>定义缩写</li></ul><h3 id="lt-acronym-gt"><a href="#lt-acronym-gt" class="headerlink" title="&lt; acronym &gt;"></a>&lt; acronym &gt;</h3><ul><li>定义缩写</li></ul><h3 id="lt-address-gt"><a href="#lt-address-gt" class="headerlink" title="&lt; address &gt;"></a>&lt; address &gt;</h3><ul><li>定义地址文本</li></ul><h3 id="lt-bdo-gt"><a href="#lt-bdo-gt" class="headerlink" title="&lt; bdo &gt;"></a>&lt; bdo &gt;</h3><ul><li>定义文字方向</li></ul><h3 id="lt-blockquote-gt"><a href="#lt-blockquote-gt" class="headerlink" title="&lt; blockquote &gt;"></a>&lt; blockquote &gt;</h3><ul><li>定义长引用</li></ul><h3 id="lt-q-gt"><a href="#lt-q-gt" class="headerlink" title="&lt; q &gt;"></a>&lt; q &gt;</h3><ul><li>定义短引用</li></ul><h3 id="lt-cite-gt"><a href="#lt-cite-gt" class="headerlink" title="&lt; cite &gt;"></a>&lt; cite &gt;</h3><ul><li>定义著作的标题</li></ul><h2 id="七-HTML表格"><a href="#七-HTML表格" class="headerlink" title="七.HTML表格"></a>七.HTML表格</h2><h3 id="lt-table-gt"><a href="#lt-table-gt" class="headerlink" title="&lt; table&gt;"></a>&lt; table&gt;</h3><ul><li><p>border</p><ul><li>设置表格边框</li></ul></li></ul><h3 id="lt-tr-gt"><a href="#lt-tr-gt" class="headerlink" title="&lt; tr &gt;"></a>&lt; tr &gt;</h3><ul><li>定义表格行</li></ul><h3 id="lt-td-gt"><a href="#lt-td-gt" class="headerlink" title="&lt; td &gt;"></a>&lt; td &gt;</h3><ul><li>定义表格单元格</li></ul><h3 id="lt-th-gt"><a href="#lt-th-gt" class="headerlink" title="&lt; th &gt;"></a>&lt; th &gt;</h3><ul><li>定义表格表头</li></ul><h3 id="lt-thead-gt"><a href="#lt-thead-gt" class="headerlink" title="&lt; thead &gt;"></a>&lt; thead &gt;</h3><p>1.thead.tbody应该与tfoot元素组合实用。<br>2.可与css组合，改变表格外观。</p><ul><li>对表格表头进行处理</li></ul><h3 id="lt-tbody-gt"><a href="#lt-tbody-gt" class="headerlink" title="&lt; tbody &gt;"></a>&lt; tbody &gt;</h3><ul><li>对表格主要内容进行处理</li></ul><h3 id="lt-tfoot-gt"><a href="#lt-tfoot-gt" class="headerlink" title="&lt; tfoot &gt;"></a>&lt; tfoot &gt;</h3><ul><li>对表格页脚进行处理</li></ul><h2 id="八-HTML列表"><a href="#八-HTML列表" class="headerlink" title="八.HTML列表"></a>八.HTML列表</h2><h3 id="lt-ol-gt"><a href="#lt-ol-gt" class="headerlink" title="&lt; ol &gt;"></a>&lt; ol &gt;</h3><ul><li>定义有序列表</li></ul><h3 id="lt-ul-gt"><a href="#lt-ul-gt" class="headerlink" title="&lt; ul &gt;"></a>&lt; ul &gt;</h3><ul><li>定义无序列表</li></ul><h3 id="lt-li-gt"><a href="#lt-li-gt" class="headerlink" title="&lt; li &gt;"></a>&lt; li &gt;</h3><ul><li>定义列表项，适用于有序和无序列表列表项</li></ul><h3 id="lt-dl-gt"><a href="#lt-dl-gt" class="headerlink" title="&lt; dl &gt;"></a>&lt; dl &gt;</h3><ul><li>定义自定义列表</li></ul><h3 id="lt-dt-gt"><a href="#lt-dt-gt" class="headerlink" title="&lt; dt &gt;"></a>&lt; dt &gt;</h3><ul><li>定义自定义列表项</li></ul><h3 id="lt-dd-gt"><a href="#lt-dd-gt" class="headerlink" title="&lt; dd &gt;"></a>&lt; dd &gt;</h3><ul><li>定义自定义列表项的内容</li></ul><h2 id="九-HTML类"><a href="#九-HTML类" class="headerlink" title="九.HTML类"></a>九.HTML类</h2><p>为HTML设置类，使用不同的css样式。</p><h3 id="lt-div-gt"><a href="#lt-div-gt" class="headerlink" title="&lt; div &gt;"></a>&lt; div &gt;</h3><ul><li>块级元素，可作为HTML元素的容器 </li></ul><h3 id="lt-span-gt"><a href="#lt-span-gt" class="headerlink" title="&lt; span &gt;"></a>&lt; span &gt;</h3><ul><li>行内元素，可作为文本的容器</li></ul><h2 id="十-HTML布局"><a href="#十-HTML布局" class="headerlink" title="十.HTML布局"></a>十.HTML布局</h2><h3 id="lt-header-gt"><a href="#lt-header-gt" class="headerlink" title="&lt; header &gt;"></a>&lt; header &gt;</h3><ul><li>用于定义文档或节的页眉</li></ul><h3 id="lt-nav-gt"><a href="#lt-nav-gt" class="headerlink" title="&lt; nav &gt;"></a>&lt; nav &gt;</h3><ul><li>用于定义文章的导航</li></ul><h3 id="lt-section-gt"><a href="#lt-section-gt" class="headerlink" title="&lt; section &gt;"></a>&lt; section &gt;</h3><ul><li>用于定义文章中的各节内容</li></ul><h3 id="lt-footer-gt"><a href="#lt-footer-gt" class="headerlink" title="&lt; footer &gt;"></a>&lt; footer &gt;</h3><ul><li>用于定义文章中的页脚</li></ul><h2 id="十一-HTML框架"><a href="#十一-HTML框架" class="headerlink" title="十一.HTML框架"></a>十一.HTML框架</h2><h3 id="lt-frameset-gt"><a href="#lt-frameset-gt" class="headerlink" title="&lt; frameset &gt;"></a>&lt; frameset &gt;</h3><p>定义如何将窗口分割成框架。</p><ul><li><p>cows</p><ul><li>定义水平框架</li></ul></li><li><p>lows</p><ul><li>定义垂直框架</li></ul></li></ul><h3 id="lt-frame-gt"><a href="#lt-frame-gt" class="headerlink" title="&lt; frame &gt;"></a>&lt; frame &gt;</h3><ul><li>定义框架的HTML文档</li></ul><h3 id="lt-iframe-gt"><a href="#lt-iframe-gt" class="headerlink" title="&lt; iframe &gt;"></a>&lt; iframe &gt;</h3><p>1.定义内联框架（在网页内显示网页）</p><ul><li><p>flame border</p><ul><li>定义框架边框</li></ul></li><li><p>width</p><ul><li>定义框架宽度</li></ul></li><li><p>height</p><ul><li>定义框架高度</li></ul></li><li><p>name</p><ul><li>规定iframe的名称</li></ul></li></ul><h2 id="十二-HTML脚本"><a href="#十二-HTML脚本" class="headerlink" title="十二.HTML脚本"></a>十二.HTML脚本</h2><h3 id="lt-script-gt"><a href="#lt-script-gt" class="headerlink" title="&lt; script &gt;"></a>&lt; script &gt;</h3><ul><li>元素可以是脚本</li><li>也可以通过src属性指向脚本文件</li></ul><h2 id="十三-HTML头部元素"><a href="#十三-HTML头部元素" class="headerlink" title="十三.HTML头部元素"></a>十三.HTML头部元素</h2><h3 id="lt-head-gt"><a href="#lt-head-gt" class="headerlink" title="&lt; head &gt;"></a>&lt; head &gt;</h3><ul><li>定义HTML头部元素，是HTML所有头部元素的容器。</li><li>2.是HTML，xHTML文档必有的元素。</li></ul><h3 id="lt-base-gt"><a href="#lt-base-gt" class="headerlink" title="&lt; base &gt;"></a>&lt; base &gt;</h3><ul><li><p>href</p><ul><li>为页面设置默认的链接地址</li></ul></li><li><p>target</p><ul><li>规定链接默认的打开方式</li></ul></li></ul><h3 id="lt-link-gt-1"><a href="#lt-link-gt-1" class="headerlink" title="&lt; link &gt;"></a>&lt; link &gt;</h3><p>1.定义当前文档与外部资源的关系。<br>2.只能作为head的元素。</p><ul><li><p>href</p><ul><li>定义外部资源的地址</li></ul></li><li><p>hreflang</p><ul><li>规定外部资源的文本语言</li></ul></li><li><p>rel</p><ul><li>规定当前文档与外部资源的关系</li></ul></li></ul><h3 id="lt-title-gt"><a href="#lt-title-gt" class="headerlink" title="&lt; title &gt;"></a>&lt; title &gt;</h3><p>1.定义文档的标题。<br>2.是HTML xHTML文档必需的。</p><ul><li><p>常见用途</p><ul><li>提供页面被添加到收藏夹时显示的标题</li><li>定义浏览器工具栏中的标题</li><li>显示在搜索引擎结果中的页面标题</li></ul></li></ul><h3 id="lt-meta-gt"><a href="#lt-meta-gt" class="headerlink" title="&lt; meta &gt;"></a>&lt; meta &gt;</h3><p>1.提供元数据，不会显示在页面上。<br>2.为搜索引擎定义关键词。<br>3.为网页定义描述内容。<br>4.定义网页作者。<br>5.刷新当前页面</p><ul><li><p>name</p><ul><li>定义context属性的名称</li></ul></li><li><p>context</p><ul><li>定义元数据内容</li></ul></li><li><p>http-equiv</p><ul><li>把context内容关联到HTTP头部</li></ul></li></ul><h2 id="十四-HTML字符实体"><a href="#十四-HTML字符实体" class="headerlink" title="十四.HTML字符实体"></a>十四.HTML字符实体</h2><h3 id="HTML中的预留字符要用字符实体表示"><a href="#HTML中的预留字符要用字符实体表示" class="headerlink" title="HTML中的预留字符要用字符实体表示"></a>HTML中的预留字符要用字符实体表示</h3><h3 id="字符实体的两种表示方法："><a href="#字符实体的两种表示方法：" class="headerlink" title="字符实体的两种表示方法："></a>字符实体的两种表示方法：</h3><ul><li>&amp;字符实体名</li><li>&amp;#字符实体数字</li></ul><h2 id="十五-HTML字符编码"><a href="#十五-HTML字符编码" class="headerlink" title="十五.HTML字符编码"></a>十五.HTML字符编码</h2><h3 id="使用url编码的原因："><a href="#使用url编码的原因：" class="headerlink" title="使用url编码的原因："></a>使用url编码的原因：</h3><ul><li>url通常会包含非Ascll编码以外的字符，需要转化为有效的Ascll格式</li></ul><h3 id="编码方式："><a href="#编码方式：" class="headerlink" title="编码方式："></a>编码方式：</h3><ul><li>%后加两位的16进制数</li></ul><h2 id="十六-HTML媒体"><a href="#十六-HTML媒体" class="headerlink" title="十六.HTML媒体"></a>十六.HTML媒体</h2><h3 id="HTML插件也叫辅助应用程序，用于扩展浏览器的功能"><a href="#HTML插件也叫辅助应用程序，用于扩展浏览器的功能" class="headerlink" title="HTML插件也叫辅助应用程序，用于扩展浏览器的功能."></a>HTML插件也叫辅助应用程序，用于扩展浏览器的功能.</h3><h3 id="插件可用标签或者标签加载"><a href="#插件可用标签或者标签加载" class="headerlink" title="插件可用标签或者标签加载."></a>插件可用<object>标签或者<embed>标签加载.</h3><h3 id="可使用或标签显示音频或视频"><a href="#可使用或标签显示音频或视频" class="headerlink" title="可使用或标签显示音频或视频."></a>可使用<audio>或<video>标签显示音频或视频.</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技术笔记" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Hexo版本升级指南</title>
    <link href="http://example.com/2021/06/05/studynotes/Hexo-upgrade/"/>
    <id>http://example.com/2021/06/05/studynotes/Hexo-upgrade/</id>
    <published>2021-06-05T03:47:05.918Z</published>
    <updated>2020-09-05T11:56:14.129Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo版本升级指南"><a href="#Hexo版本升级指南" class="headerlink" title="Hexo版本升级指南"></a>Hexo版本升级指南</h1><h3 id="1-更新升级hexo"><a href="#1-更新升级hexo" class="headerlink" title="1.更新升级hexo"></a>1.更新升级hexo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h3 id="2-查看可更新npm依赖包并升级"><a href="#2-查看可更新npm依赖包并升级" class="headerlink" title="2.查看可更新npm依赖包并升级"></a>2.查看可更新npm依赖包并升级</h3><h4 id="安装npm-check包"><a href="#安装npm-check包" class="headerlink" title="安装npm-check包"></a>安装npm-check包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install npm-check -g</span><br></pre></td></tr></table></figure><h4 id="检查可更新依赖包并升级"><a href="#检查可更新依赖包并升级" class="headerlink" title="检查可更新依赖包并升级"></a>检查可更新依赖包并升级</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm-check -u</span><br></pre></td></tr></table></figure><p><strong>or</strong></p><h4 id="安装npm-upgrade包"><a href="#安装npm-upgrade包" class="headerlink" title="安装npm-upgrade包"></a>安装npm-upgrade包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-upgrade</span><br></pre></td></tr></table></figure><h4 id="检查可更新依赖包件并升级"><a href="#检查可更新依赖包件并升级" class="headerlink" title="检查可更新依赖包件并升级"></a>检查可更新依赖包件并升级</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm-upgrade</span><br></pre></td></tr></table></figure><h3 id="4-更新"><a href="#4-更新" class="headerlink" title="4.更新"></a>4.更新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update -g</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update --save</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="技术笔记" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="npm" scheme="http://example.com/tags/npm/"/>
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
</feed>
